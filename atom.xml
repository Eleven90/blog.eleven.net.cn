<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eleven</title>
  
  
  <link href="https://blog.eleven.net.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.eleven.net.cn/"/>
  <updated>2021-03-26T08:29:02.145Z</updated>
  <id>https://blog.eleven.net.cn/</id>
  
  <author>
    <name>eleven.net.cn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无 eject 重写 CRA 配置 —— craco 详解</title>
    <link href="https://blog.eleven.net.cn/2020/09/11/cra-rewrite/index/"/>
    <id>https://blog.eleven.net.cn/2020/09/11/cra-rewrite/index/</id>
    <published>2020-09-11T08:43:40.000Z</published>
    <updated>2021-03-26T08:29:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>使用 CRA 脚手架创建的项目，如果想要修改编译配置，通常可能会选择 <code>npm run eject</code> 弹出配置后魔改。但是，eject 是不可逆操作，弹出配置后，你将无法跟随官方的脚步去升级项目的 react-script 版本。</p><p>如果想要无 eject 重写 CRA 配置，一般可以有以下几种方式</p><ol><li>通过 CRA 官方支持的 <code>--scripts-version</code> 参数，创建项目时使用自己重写过的 react-scripts 包</li><li>使用 <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> + <a href="https://github.com/arackaf/customize-cra">customize-cra</a> 组合覆盖配置</li><li>使用 <a href="https://github.com/gsoft-inc/craco">craco</a> 覆盖配置</li></ol><p>第一种方式很棒，但这里暂时不做讨论，感兴趣的可以从下方链接了解更多：</p><ol><li>CRA 官方的介绍：<a href="https://create-react-app.dev/docs/alternatives-to-ejecting/">Alternatives to Ejecting</a></li><li><a href="https://auth0.com/blog/how-to-configure-create-react-app/">Customizing create-react-app: How to Make Your Own Template</a></li></ol><p>第二种方式相对第三种略复杂一些，并且我注意到 AntDesign 官方也开始推荐 <a href="https://github.com/gsoft-inc/craco">craco</a> 了，这里详细讨论一下第三种 <a href="https://github.com/gsoft-inc/craco">craco</a> 的使用，经过项目的实测，用起来还算顺手。</p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol><li><p>安装包</p><pre><code class="sh"> yarn add @craco/craco</code></pre></li><li><p>项目根目录创建 <code>craco.config.js</code> 文件</p><pre><code class="js"> /* craco.config.js */ module.exports = &#123;   ... &#125;</code></pre></li><li><p>修改 package.json 的 scripts 命令</p><pre><code class="json"> /* package.json */ &quot;scripts&quot;: &#123; -   &quot;start&quot;: &quot;react-scripts start&quot;, +   &quot;start&quot;: &quot;craco start&quot;, -   &quot;build&quot;: &quot;react-scripts build&quot;, +   &quot;build&quot;: &quot;craco build&quot; -   &quot;test&quot;: &quot;react-scripts test&quot;, +   &quot;test&quot;: &quot;craco test&quot; &#125;</code></pre></li></ol><p>基础的配置到此完成了，接下来是处理各种配置的覆盖，完整的 craco.config.js 配置文件结构，可以在 craco 官方的文档中详细查询：<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a> 。</p><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><p>@craco/craco 提供了 <code>whenDev、whenProd、whenTest、when</code> 函数，用于在书写 craco.config.js 配置文件时根据不同的编译环境确定配置，先看一下 craco 相关的源码：</p><pre><code class="js">function when(condition, fct, unmetValue) &#123;    if (condition) &#123;        return fct();    &#125;    return unmetValue;&#125;function whenDev(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;development&quot;, fct, unmetValue);&#125;function whenProd(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;production&quot;, fct, unmetValue);&#125;function whenTest(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;test&quot;, fct, unmetValue);&#125;module.exports = &#123;    when,    whenDev,    whenProd,    whenTest&#125;;</code></pre><ul><li><p><code>whenDev、whenProd、whenTest</code> 分别对应的是 <code>process.env.NODE_ENV</code> 的 3 种值（<code>development</code>、<code>production</code>、<code>test</code>），接收两个参数：</p><ul><li>第一个参数是 function，对应该编译环境下，执行函数，函数一般应当将需要的配置作为返回值。</li><li>第二个参数是默认值，非指定编译环境时，返回该默认值。</li></ul></li><li><p><code>when</code> 是区分环境的万金油函数，接收 3 个参数：</p><ul><li>第一个参数是判断的变量。</li><li>第二个参数是 function，参数一的变量为 true 时，执行该函数，函数一般应当将需要的配置作为返回值。</li><li>第三个参数是默认值，参数一的变量为 false 时，返回该默认值。</li></ul></li></ul><p>引用方式：</p><pre><code class="js">const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)</code></pre><p>下方的示例中有多处使用，可以参照了解其用途。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>craco 有提供一些 <a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">plugins</a>，集成了诸多功能，让覆盖配置变得更加容易。</p><p>除此之外，则需要我们对 webpack 的配置有一定的了解，根据 craco.config.js 的文件结构去增加配置。</p><h4 id="通过-configure-函数扩展-webpack-配置"><a href="#通过-configure-函数扩展-webpack-配置" class="headerlink" title="通过 configure 函数扩展 webpack 配置"></a>通过 configure 函数扩展 webpack 配置</h4><p>几乎所有的 webpack 配置均可以在 configure 函数中读取、覆盖，webpack 详细的配置参数结构可以查阅 webpack 官方的文档：<a href="https://webpack.js.org/configuration/">https://webpack.js.org/configuration/</a> 。</p><p>需要注意一点，configure 既可以定义为对象，也可以定义为函数，使用过程中，我发现二者是互斥的关系。这里推荐使用函数形式，因为当我想要覆盖 <code>mini-css-extract-plugin</code> 的配置时，发现对象形式的 configure 定义，不能达到目的。</p><p>configure 可以扩展所有的 webpack 配置，你可以将所有的配置都在 configure 中写完，但是，craco 提供了若干快捷的方式去定义指定的配置，例如：babel、alias、webpack 的 plugins 等。因此，推荐有快捷的方式尽量用快捷方式，搞不定的才放到 configure 中去定义。</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    /**     * 重写 webpack 任意配置     *  - 与直接定义 configure 对象方式互斥     *  - 几乎所有的 webpack 配置均可以在 configure 函数中读取，然后覆盖     */    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;      // 修改 output      webpackConfig.output = &#123;        ...webpackConfig.output,        ...&#123;          filename: whenDev(() =&gt; &#39;static/js/bundle.js&#39;, &#39;static/js/[name].js&#39;),          chunkFilename: &#39;static/js/[name].js&#39;,        &#125;,      &#125;      // 关闭 devtool      webpackConfig.devtool = false      // 配置扩展扩展名      webpackConfig.resolve.extensions = [        ...webpackConfig.resolve.extensions,        ...[&#39;.scss&#39;, &#39;.less&#39;],      ]      // 配置 splitChunks      webpackConfig.optimization.splitChunks = &#123;        ...webpackConfig.optimization.splitChunks,        ...&#123;          chunks: &#39;all&#39;,          name: true,        &#125;,      &#125;      // 覆盖已经内置的 plugin 配置      webpackConfig.plugins.map((plugin) =&gt; &#123;        whenProd(() =&gt; &#123;          if (plugin instanceof MiniCssExtractPlugin) &#123;            Object.assign(plugin.options, &#123;              filename: &#39;static/css/[name].css&#39;,              chunkFilename: &#39;static/css/[name].css&#39;,            &#125;)          &#125;        &#125;)        return plugin      &#125;)      return webpackConfig    &#125;,  &#125;&#125;</code></pre><h4 id="扩展-babel-配置"><a href="#扩展-babel-配置" class="headerlink" title="扩展 babel 配置"></a>扩展 babel 配置</h4><p>虽然可以在 configure 中定义 babel 配置，但 craco 也提供了快捷的方式单独去书写，添加 <code>@babel/preset-env</code> 配置示例如下：</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;    presets: [      [        &#39;@babel/preset-env&#39;,        &#123;          modules: false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等          useBuiltIns: &#39;entry&#39;, // browserslist环境不支持的所有垫片都导入          // https://babeljs.io/docs/en/babel-preset-env#usebuiltins          // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md          corejs: &#123;            version: 3, // 使用core-js@3            proposals: true,          &#125;,        &#125;,      ],    ],    plugins: [    ],  &#125;,&#125;</code></pre><p>更详细的 babel 相关配置，推荐我之前整理的：<a href="https://webpack.eleven.net.cn/content/babel/">https://webpack.eleven.net.cn/content/babel/</a> 。</p><h4 id="扩展-webpack-alias（别名）"><a href="#扩展-webpack-alias（别名）" class="headerlink" title="扩展 webpack alias（别名）"></a>扩展 webpack alias（别名）</h4><p>虽然可以在 configure 中定义 alias，但 craco 也提供了快捷的方式单独去书写。</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;    &#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,  &#125;&#125;</code></pre><p>这里有一个坑点，如果你使用的是 cra 创建的 typescript 项目，添加完 alias 后，你还需要在 tsconfig.json 文件中新增配置，否则会提示出错。并且，新版本 cra 创建的项目，在编译时会自动格式化 tsconfig.json，你向里面添加的若干配置，可能会自动被清除掉。</p><p>怎么办？这里寻找到一个机智的办法，利用 tsconfig 的 extends 参数去扩展需要的配置。</p><p>tsconfig.json</p><pre><code class="json">&#123;  &quot;extends&quot;: &quot;./tsconfig.edit.json&quot;,  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;lib&quot;: [      &quot;dom&quot;,      &quot;dom.iterable&quot;,      &quot;esnext&quot;    ],    &quot;allowJs&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;strict&quot;: true,    &quot;forceConsistentCasingInFileNames&quot;: true,    &quot;module&quot;: &quot;esnext&quot;,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;resolveJsonModule&quot;: true,    &quot;isolatedModules&quot;: true,    &quot;noEmit&quot;: true,    &quot;jsx&quot;: &quot;react&quot;  &#125;,  &quot;include&quot;: [    &quot;src&quot;  ]&#125;</code></pre><p>tsconfig.edit.json</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;src/*&quot;]    &#125;  &#125;&#125;</code></pre><p>通过继承的方式，添加如上配置，alias 修改即可完成。</p><p>另外，craco 也提供了一个 plugin 专门用于修改 alias，以及处理 tsconfig 的问题，<a href="https://github.com/risenforces/craco-alias">传送门</a>，该页面下方的 Examples 中，详细说明了 tsconfig 的方案，推荐使用。</p><h4 id="新增-webpack-plugins"><a href="#新增-webpack-plugins" class="headerlink" title="新增 webpack plugins"></a>新增 webpack plugins</h4><p>如果想要新增一些 webpack plugins，可以直接在与 configure 平级的位置添加。当然，你在 configure 里添加也可以，但不推荐。</p><p>需要注意的是，如果你想修改内置的某些 webpack plugin 参数，必须到 configure 里去修改，示例见上方的 configure 介绍。</p><p>示例如下：</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)const CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)const &#123; BundleAnalyzerPlugin &#125; = require(&#39;webpack-bundle-analyzer&#39;)module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;    &#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,    plugins: [ // 新增 webpack plugin      // 新增模块循环依赖检测插件      ...whenDev(        () =&gt; [          new CircularDependencyPlugin(&#123;            exclude: /node_modules/,            include: /src/,            failOnError: true,            allowAsyncCycles: false,            cwd: process.cwd(),          &#125;),        ],        [],      ),      // 新增打包产物分析插件      ...whenProd(        () =&gt; [          // https://www.npmjs.com/package/webpack-bundle-analyzer          new BundleAnalyzerPlugin(&#123;            analyzerMode: &#39;static&#39;, // html 文件方式输出编译分析            openAnalyzer: false,            reportFilename: path.resolve(__dirname, `analyzer/index.html`),          &#125;),        ],        [],      ),    ],  &#125;&#125;</code></pre><h4 id="扩展-react-hot-loader"><a href="#扩展-react-hot-loader" class="headerlink" title="扩展 react-hot-loader"></a>扩展 react-hot-loader</h4><p>常用的热更新方案 react-hot-loader，craco 提供了专门的 craco plugin（<a href="https://github.com/HasanAyan/craco-plugin-react-hot-reload">传送门</a>），配置如下：</p><pre><code class="sh">yarn add craco-plugin-react-hot-reload -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)const reactHotReloadPlugin = require(&#39;craco-plugin-react-hot-reload&#39;)module.exports = &#123;  babel: &#123;  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [    // 新增 craco-plugin-react-hot-reload      ...whenDev(      () =&gt; [        &#123;          plugin: reactHotReloadPlugin,        &#125;,      ],      [],    ),  ]&#125;</code></pre><p>添加完配置，还需在入口文件中修改一下 render。</p><pre><code class="sh">yarn add react-hot-loader -D</code></pre><pre><code class="js">/* 入口 index.ts */import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;+ import &#123; hot &#125; from &#39;react-hot-loader&#39;+ import &#123; isDev &#125; from &#39;@/utils&#39; // isDev 你可以自己编写定义，例如：const isDev = process.env.NODE_ENV === &#39;development&#39;import App from &#39;./App&#39;+ const Root = isDev ? hot(module)(App) : App- ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))+ ReactDOM.render(&lt;Root /&gt;, document.getElementById(&#39;root&#39;))</code></pre><h4 id="比-react-hot-loader-更好的方案-craco-fast-refresh"><a href="#比-react-hot-loader-更好的方案-craco-fast-refresh" class="headerlink" title="比 react-hot-loader 更好的方案 craco-fast-refresh"></a>比 react-hot-loader 更好的方案 craco-fast-refresh</h4><p>这是最近发现的新 craco plugin，相对于 react-hot-loader 好用得多，零配置，不需要修改项目代码，据说性能也更好。</p><pre><code class="sh">yarn add craco-fast-refresh -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev &#125; = require(&#39;@craco/craco&#39;)const fastRefreshCracoPlugin = require(&#39;craco-fast-refresh&#39;)module.exports = &#123;  babel: &#123;  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [      ...whenDev(      () =&gt; [        &#123;          plugin: fastRefreshCracoPlugin,        &#125;,      ],      [],    ),  ]&#125;</code></pre><h4 id="AntDesign-自定义主题-amp-按需加载"><a href="#AntDesign-自定义主题-amp-按需加载" class="headerlink" title="AntDesign 自定义主题 &amp; 按需加载"></a>AntDesign 自定义主题 &amp; 按需加载</h4><ul><li>在 bebel 配置中新增 <code>babel-plugin-import</code>，搞定 AntDesign 按需加载</li><li>新增 craco 提供的 plugin <code>craco-less</code>，搞定自定义主题</li></ul><pre><code class="sh">yarn add babel-plugin-import craco-less -D</code></pre><pre><code class="js">/* craco.config.js */const CracoLessPlugin = require(&#39;craco-less&#39;)module.exports = &#123;  babel: &#123;    plugins: [      // 配置 babel-plugin-import      [        &#39;import&#39;,        &#123;          libraryName: &#39;antd&#39;,          libraryDirectory: &#39;es&#39;,          style: &#39;css&#39;,        &#125;,        &#39;antd&#39;,      ],    ],  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [    // 配置 less      &#123;      plugin: CracoLessPlugin,      options: &#123;        lessLoaderOptions: &#123;          lessOptions: &#123;            modifyVars: &#123;              // 自定义主题（如果有需要，单独文件定义更好一些）              &#39;@primary-color&#39;: &#39;#1DA57A&#39;,            &#125;,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,  ]&#125;</code></pre><p>craco 也提供了专门的 plugin 来处理 antd 的集成（<a href="https://github.com/DocSpring/craco-antd">传送门</a>），与上方的配置方式有区别。从 github 的介绍中能够看到如下介绍：</p><p>craco-antd includes:</p><ul><li>Less (provided by craco-less)</li><li>babel-plugin-import to only import the required CSS, instead of everything</li><li>An easy way to customize the theme. Set your custom variables in ./antd.customize.less</li></ul><p>相对来讲使用会更简洁一些，推荐使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过项目中的试用，确实能够在不 eject 弹出配置的情况下，自定义所有的 cra 构建配置，因此，在后续的编码中，我应该还会继续使用。</p><p>上方是最近在项目中，使用到的一些配置，更多的使用方式建议通过阅读官方的文档（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md">传送门</a>）去了解，尤其需要详细了解 craco.config.js 文件的配置列表（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a>）。</p><p>有几点建议如下：</p><ol><li><p>craco 有提供一些好用的 plugin（<a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">传送门</a>），推荐优先考虑使用现成的插件去解决问题。</p><p> 注意 craco 的 plugin 与 webpack plugin 不是同一概念，二者配置的位置也不同。</p></li><li><p>webpack 相关的配置覆盖，优先使用 craco 提供的快捷方式去配置。</p><p> 解决不了的问题，在 configure 函数中配置，并且，推荐 configure 使用函数形式，而非对象形式。虽然，函数形式更复杂了一点，但是二者是互斥的，只好选择其中一种。</p></li></ol><p>最后，放一份完整的 craco.config.js 配置文件，方便参照。</p><pre><code class="js">/* * @Desc: craco 重写 CRA 配置 *  - https://github.com/gsoft-inc/craco * * @Author: Eleven * @Date: 2020-08-14 12:14:00 * @Last Modified by: Eleven * @Last Modified time: 2020-09-11 10:42:48 */const path = require(&#39;path&#39;)const webpack = require(&#39;webpack&#39;)const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)const &#123; BundleAnalyzerPlugin &#125; = require(&#39;webpack-bundle-analyzer&#39;)const CracoLessPlugin = require(&#39;craco-less&#39;)const CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)const TsconfigPathsPlugin = require(&#39;tsconfig-paths-webpack-plugin&#39;)const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)const fastRefreshCracoPlugin = require(&#39;craco-fast-refresh&#39;)module.exports = &#123;  // 扩展 babel 配置  babel: &#123;    presets: [      [        &#39;@babel/preset-env&#39;,        &#123;          modules: false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等          useBuiltIns: &#39;entry&#39;, // browserslist环境不支持的所有垫片都导入          // https://babeljs.io/docs/en/babel-preset-env#usebuiltins          // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md          corejs: &#123;            version: 3, // 使用core-js@3            proposals: true,          &#125;,        &#125;,      ],    ],    plugins: [      [        &#39;import&#39;,        &#123;          libraryName: &#39;antd&#39;,          libraryDirectory: &#39;es&#39;,          style: &#39;css&#39;,        &#125;,        &#39;antd&#39;,      ],    ],  &#125;,  // 扩展 webpack 相关配置  webpack: &#123;    /**     * 重写 webpack 任意配置     *  - 与直接定义 configure 对象方式互斥     */    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;      webpackConfig.output = &#123;        ...webpackConfig.output,        ...&#123;          filename: whenDev(() =&gt; &#39;static/js/bundle.js&#39;, &#39;static/js/[name].js&#39;),          chunkFilename: &#39;static/js/[name].js&#39;,        &#125;,      &#125;      webpackConfig.resolve.extensions = [        ...webpackConfig.resolve.extensions,        ...[&#39;.scss&#39;, &#39;.less&#39;],      ]      webpackConfig.optimization.splitChunks = &#123;        ...webpackConfig.optimization.splitChunks,        ...&#123;          chunks: &#39;all&#39;,          name: true,        &#125;,      &#125;      // 覆盖已经内置的 plugin 配置      webpackConfig.plugins.map((plugin) =&gt; &#123;        whenProd(() =&gt; &#123;          if (plugin instanceof MiniCssExtractPlugin) &#123;            Object.assign(plugin.options, &#123;              filename: &#39;static/css/[name].css&#39;,              chunkFilename: &#39;static/css/[name].css&#39;,            &#125;)          &#125;        &#125;)        return plugin      &#125;)      return webpackConfig    &#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,    resolve: &#123;      plugins: [new TsconfigPathsPlugin()],    &#125;,    plugins: [      // 新增 plugin      ...whenDev(        () =&gt; [          new CircularDependencyPlugin(&#123;            exclude: /node_modules/,            include: /src/,            failOnError: true,            allowAsyncCycles: false,            cwd: process.cwd(),          &#125;),        ],        [],      ),      ...whenProd(        () =&gt; [          // https://www.npmjs.com/package/webpack-bundle-analyzer          new BundleAnalyzerPlugin(&#123;            analyzerMode: &#39;static&#39;, // html 文件方式输出编译分析            openAnalyzer: false,            reportFilename: path.resolve(__dirname, `analyzer/index.html`),          &#125;),        ],        [],      ),    ],  &#125;,  // craco 提供的插件  plugins: [    ...whenDev(      () =&gt; [        &#123;          plugin: fastRefreshCracoPlugin,        &#125;,      ],      [],    ),    &#123;      plugin: CracoLessPlugin,      options: &#123;        lessLoaderOptions: &#123;          lessOptions: &#123;            // modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,  ],&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 CRA 脚手架创建的项目，如果想要修改编译配置，通常可能会选择 &lt;code&gt;npm run eject&lt;/code&gt; 弹出配置后魔改。但是，eject 是不可逆操作，弹出配置后，你将无法跟随官方的脚步去升级项目的 react-script 版本。&lt;/p&gt;
&lt;p&gt;如果想</summary>
      
    
    
    
    <category term="react" scheme="https://blog.eleven.net.cn/categories/react/"/>
    
    
    <category term="create-react-app" scheme="https://blog.eleven.net.cn/tags/create-react-app/"/>
    
  </entry>
  
  <entry>
    <title>1px 细线实现</title>
    <link href="https://blog.eleven.net.cn/2020/08/26/css/border/"/>
    <id>https://blog.eleven.net.cn/2020/08/26/css/border/</id>
    <published>2020-08-26T12:26:13.000Z</published>
    <updated>2021-03-26T08:29:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>采用缩放方案，单条边线好处理一点；如果需要四边都有边线，会有点麻烦，使用缩放方案，虽然可行，但是在部分设备上有间隙问题，建议放弃，或者使用 svg 来做 background-image。</p><p>以下是 less/sass 的简单实现示例。</p><h3 id="LESS-上边线-1px"><a href="#LESS-上边线-1px" class="headerlink" title="LESS 上边线 1px"></a>LESS 上边线 1px</h3><pre><code class="less">.border-top(@color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    top: 0;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-top: 1px solid @color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  .border-top(#eee);&#125;</code></pre><h3 id="SASS-上下-1px-细线"><a href="#SASS-上下-1px-细线" class="headerlink" title="SASS 上下 1px 细线"></a>SASS 上下 1px 细线</h3><pre><code class="scss">/** * 1px细线 *  $position top/bottom */@mixin border-1px($position, $color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    @if $position == top &#123;      top: 0;    &#125;    @if $position == bottom &#123;      bottom: 0;    &#125;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-#&#123;$position&#125;: 1px solid $color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  // 上边线  @include border-1px(top, #e9e9e9);  // 下边线  @include border-1px(bottom, #e9e9e9);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;采用缩放方案，单条边线好处理一点；如果需要四边都有边线，会有点麻烦，使用缩放方案，虽然可行，但是在部分设备上有间隙问题，建议放弃，或者使用 svg 来做 background-image。&lt;/p&gt;
&lt;p&gt;以下是 less/sass 的简单实现示例。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="CSS3" scheme="https://blog.eleven.net.cn/categories/CSS3/"/>
    
    
    <category term="CSS3" scheme="https://blog.eleven.net.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>模块间循环引用问题</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/circular-dependency/index/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/circular-dependency/index/</id>
    <published>2020-06-11T10:02:52.000Z</published>
    <updated>2021-03-26T08:29:02.141Z</updated>
    
    <content type="html"><![CDATA[<p>有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。</p><p>类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的模块……</p><p>为了更好地避免这样的问题，可以使用 <a href="https://github.com/aackerman/circular-dependency-plugin">circular-dependency-plugin</a> 插件来做循环引用的检测:</p><p>基本用法如下，复制、粘贴即可生效：</p><pre><code class="js">// webpack.config.jsconst CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)module.exports = &#123;  plugins: [    new CircularDependencyPlugin(&#123;      // exclude detection of files based on a RegExp      exclude: /node_modules/,      // include specific files based on a RegExp      include: /src/,      // add errors to webpack instead of warnings      failOnError: true,      // allow import cycles that include an asyncronous import,      // e.g. via import(/* webpackMode: &quot;weak&quot; */ &#39;./file.js&#39;)      allowAsyncCycles: false,      // set the current working directory for displaying module paths      cwd: process.cwd(),    &#125;)  ]&#125;</code></pre><p>检测到问题时，会看到如下图的编译提示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/10/16eefa622ebb1ebf?w=1060&h=230&f=png&s=51565" alt=""></p><p>如何解决循环引用的问题？将被循环引用到的模块提取放到另外的模块，打破这个循环即可！</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li><a href="https://www.imooc.com/article/260265">webpack 与循环引用</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">JavaScript 模块的循环加载</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。&lt;/p&gt;
&lt;p&gt;类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的</summary>
      
    
    
    
    <category term="Webpack" scheme="https://blog.eleven.net.cn/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="https://blog.eleven.net.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>自动修改 node_moduels 的包</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/patch-packages/index/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/patch-packages/index/</id>
    <published>2020-06-11T02:23:01.000Z</published>
    <updated>2021-03-26T08:29:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>有时候 node_modules 中的第三方包有问题或需要修改几行源码，我们可以怎么办？</p><ol><li><p>去给作者提 issues？可能得不到回复。</p></li><li><p>自己在 node_modules 里直接修改源码？下一次重新安装包，或者其他同事 install 的时候，被修改过的源码又恢复如初了。</p></li><li><p>不用他的包，自己写一个？……</p></li></ol><p>社区提供了一个工具：<a href="https://github.com/ds300/patch-package">patch-package</a>，专门用来处理修改 node_modules 包源码的问题。</p><p>需要区分 npm 和 yarn，二者使用方法有一些区别，分开做描述。</p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><ol><li><p>在 package.json 的 scripts 中增加如下命令：</p><pre><code class="json"> &quot;scripts&quot;: &#123; +  &quot;postinstall&quot;: &quot;patch-package&quot; &#125;</code></pre><p> <code>postinstall</code> 是 npm 的钩子，会在依赖包被 <code>install</code> 之后被执行。</p></li><li><p>安装 patch-package</p><pre><code class="sh"> npm i patch-package -D</code></pre></li><li><p>上面两步都做了，就可以去修改 node_modules 里任意第三方包的源码了。</p></li><li><p>修改了源码，随后需要执行以下命令：</p><pre><code class="sh"> npx patch-package [package-name]  # [package-name] 是包名，不需要写路径。</code></pre><p> 命令执行成功后，会发现项目根目录下多了一个文件夹 <code>patches</code>，该目录下多了文件，即为记录源码修改的文件。</p><p> <img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bce8d8e01745?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p> 将 <code>patches</code> 目录及文件，通过 git 提交到代码仓库。</p></li><li><p>Over，后续其他同学不需要做额外操作，直接安装即可，node_modules 下的源码修改会自动更新。</p><p> 之前已经安装过该第三方包的同学，需要卸载，重新安装一次。</p></li><li><p>如果后续还有其它包也需要修改源码，修改过后，再执行一次命令：</p><pre><code class="sh"> npx patch-package [package-name]  # [package-name] 是包名，不需要写路径。</code></pre></li></ol><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ol><li><p>在 package.json 的 scripts 中增加如下命令：</p><pre><code class="json"> &quot;scripts&quot;: &#123; +  &quot;postinstall&quot;: &quot;patch-package&quot; &#125;</code></pre><p> <code>postinstall</code> 是 npm 的钩子，会在依赖包被 <code>install</code> 之后被执行。</p></li><li><p>安装 patch-package、postinstall-postinstall</p><pre><code class="sh"> yarn add patch-package postinstall-postinstall -D</code></pre></li><li><p>上面两步都做了，就可以去修改 node_modules 里任意第三方包的源码了。</p></li><li><p>修改了源码，随后需要执行以下命令：</p><pre><code class="sh"> yarn patch-package [package-name]  # [package-name] 是包名，不需要写路径。</code></pre><p> 命令执行成功后，会发现项目根目录下多了一个文件夹 <code>patches</code>，该目录下多了文件，即为记录源码修改的文件。</p><p> <img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bce8d8e01745?w=418&h=102&f=png&s=11416" alt=""></p><p> 将 <code>patches</code> 目录及文件，通过 git 提交到代码仓库。</p></li><li><p>Over，后续其他同学不需要做额外操作，直接安装即可，node_modules 下的源码修改会自动更新。</p><p> 之前已经安装过该第三方包的同学，需要卸载，重新安装一次。</p></li><li><p>如果后续还有其它包也需要修改源码，修改过后，再执行一次命令：</p><pre><code class="sh"> yarn patch-package [package-name]  # [package-name] 是包名，不需要写路径。</code></pre></li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li><p>过程中遇到一个错误，记录一下，其他人不一定会遇到。</p><p> macos 在终端报如下错误:</p><p> <img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bcf316c96916?w=2240&h=288&f=png&s=90956" alt=""></p><p> 可以参照这个文档解决：<a href="https://www.cnblogs.com/start-fxw/p/10192226.html">https://www.cnblogs.com/start-fxw/p/10192226.html</a></p><p> 终端运行如下命令：</p><pre><code class="bash"> xcode-select --install</code></pre><p> 更新一下 xcode 即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候 node_modules 中的第三方包有问题或需要修改几行源码，我们可以怎么办？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;去给作者提 issues？可能得不到回复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自己在 node_modules 里直接修改源码？下一次重新安装包，或者其</summary>
      
    
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/categories/NPM/"/>
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>NPM 包发布指南</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/npm-publish/index/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/npm-publish/index/</id>
    <published>2020-06-11T02:21:34.000Z</published>
    <updated>2021-03-26T08:29:02.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ol><li><p>在 NPM 官网注册账号，<a href="https://www.npmjs.com">https://www.npmjs.com</a></p><p> 邮件验证的时候可能需要翻墙访问。</p></li><li><p>本机安装 nodejs</p></li><li><p>推荐也安装一下 nrm，方便随时切换 npm 源</p><pre><code class="sh"> sudo npm i nrm -g</code></pre><p> nrm 常用命令</p><pre><code class="sh"> nrm ls                  # 查看所有 nrm use [目标源]         # 切换至目标源</code></pre></li></ol><h4 id="二、package-json-文件"><a href="#二、package-json-文件" class="headerlink" title="二、package.json 文件"></a>二、package.json 文件</h4><p>包的<strong>根目录</strong>需要有一个 package.json 文件，可以通过 <code>npm init</code> 命令去创建，示例如下：</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;@eleven.xi/reset.css&quot;,  &quot;version&quot;: &quot;1.0.6&quot;,  &quot;description&quot;: &quot;H5 网页 reset 方案，PC&amp;mobile&quot;,  &quot;main&quot;: &quot;lib/reset.css&quot;,  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;npm publish . --access=public&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/Eleven90/reset.css.git&quot;  &#125;,  &quot;keywords&quot;: [    &quot;reset.css&quot;  ],  &quot;author&quot;: &quot;Eleven&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/Eleven90/reset.css/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/Eleven90/reset.css#readme&quot;,  &quot;files&quot;: [&quot;lib&quot;, &quot;ReadMe.md&quot;]&#125;</code></pre><p><strong>文件中重点注意以下几项：</strong></p><ol><li><p>main：指定包的入口文件</p></li><li><p>name：指定包名</p><ul><li><p>发布之前都要去<a href="https://www.npmjs.com">NPM 官网</a>上搜索一遍，确认想要使用的包名，是否已经被占用。</p></li><li><p>包名支持 [@scope]/[package name] 的形式，[@scope] 类似于命名空间的作用，NPM 默认允许你使用自己注册的用户名，或者在自己的账户下申请的 organizations。</p><p>  典型的例子，如 Babel，插件原先使用的是 babel-plugin-xxx 的格式命名，后来因为许多个人发布的包和官方的包命名格式一样，导致难以区分，现在 babel 官方所有的包都更换成了 @babel/xxx 的格式。</p></li></ul></li><li><p>version：包的版本</p><ul><li>格式 <code>数字.数字.数字</code>，每一次发布，版本都必须要更新，只能往上增加。</li></ul></li><li><p>keywords：关键词</p><ul><li>希望别人通过哪些关键词搜索到你的包，可以在这里添加。</li></ul></li><li><p>files：指定哪些文件夹、文件将被发布</p><ul><li><p>如果你的项目目录下包含了一些隐私文件，不希望被发布出去，一定要注意配置此项，仅包含可以被发布的文件夹、文件。</p></li><li><p>可以在包的根目录下新建文件 <code>.npmignore</code>，指定哪些文件不被发布，书写格式与 <code>.gitignore</code> 文件一致。</p></li></ul><ol start="6"><li><p>license：协议，推荐阅读了解几种开源的协议：</p><ul><li><p><a href="https://www.jianshu.com/p/86251523e898">七种开源许可证</a></p></li><li><p><a href="https://spdx.org/licenses/">SPDX License List</a></p></li></ul></li><li><p>description、repository、author、bugs、homepage 等项，通常也推荐填写完整，详细的 package.json 每一项的含义，推荐阅读这一篇：<a href="https://blog.csdn.net/zhengxiuchen86/article/details/81285030">npm package.json属性详解</a> 。</p></li></ol></li></ol><h4 id="三、待发布的包结构"><a href="#三、待发布的包结构" class="headerlink" title="三、待发布的包结构"></a>三、待发布的包结构</h4><ol><li><p>移除不必要的代码</p><p> 发布出去的包，一般只需要包含用户使用时必须要 <code>install</code> 下载的文件即可，例如一些构建脚本等无关的代码文件，不必发布出去。</p><p> 例如：你有一个开源项目，同时，该项目也提供了包供开发者使用，最佳方式应该是将该项目源码推送到 GitHub 上开源，而发布到 NPM 仓库的包，尽量不要把项目源码目录、构建脚本等非必要的文件发布到 NPM 仓库，会增大包的体积，导致安装时间变长。</p></li><li><p>发布的包尽量要做好语法转译，否则要在文档中说明，提醒使用者自己完成。</p></li><li><p>保护隐私</p><p> 如果待发布的包，并非开源项目，而仅仅是为了提供开发者 NPM 安装、使用，一定要做好隐私保护工作，防止源码、隐私的文档等隐秘信息被发布到 NPM 仓库。可以选用的方法如下：</p><ol><li><p><code>.gitignore</code> 设置忽略哪些文件</p><p>   .gitignore 设置的忽略文件，在 git 代码管理和 npm publish 都会被忽略。</p></li><li><p>.npmignore 设置忽略哪些文件</p><p>   .npmignore 优先级更高，如果同时使用了 .npmignore 和 .gitignore，只有 .npmignore 会生效。</p></li><li><p>package.json 文件的 files 字段</p><p>   直接在 package.json 文件中配置 <code>files</code>，指定发布哪些文件、目录，优先级高于 .npmignore 和 .gitignore。</p></li></ol></li><li><p>以下文件、目录在发布时，默认会被忽略</p><pre><code class="txt"> .*.swp ._* .DS_Store .git .hg .npmrc .lock-wscript .svn .wafpickle-* config.gypi CVS npm-debug.log node_modules/</code></pre></li><li><p>以下文件、目录在发布时，默认会被包含，无法忽略掉</p><pre><code class="txt"> package.json README (and its variants) CHANGELOG (and its variants) LICENSE / LICENCE</code></pre></li></ol><h4 id="四、发布"><a href="#四、发布" class="headerlink" title="四、发布"></a>四、发布</h4><ol><li><p>登录 NPM 账号</p><ol><li><p>在终端运行命令，填写账号、密码及邮箱。</p><pre><code class="sh"> npm adduser / npm login</code></pre></li><li><p>查看是否登录上了？</p><pre><code class="sh"> npm who am i</code></pre></li><li><p>通常只有一个人可以发布，也可以添加多人，相关命令如下：</p><pre><code class="sh"> npm owner ls &lt;package name&gt;             # 查看 npm owner add &lt;user&gt; &lt;package name&gt;     # 添加 npm owner rm &lt;user&gt; &lt;package name&gt;      # 删除</code></pre></li></ol></li><li><p>发布</p><pre><code class="sh"> npm publish . --access=public</code></pre><ol><li><p>这里注意一下发布命令中的点 <code>.</code> ，如果不带 <code>.</code> ，偶尔碰到发布会出错。</p></li><li><p>包名重复（或者说已被占用）、未登录，都会导致发布失败，注意看提示信息。</p></li><li><p>注意版本号必须要递增，相同的版本号或版本号递减会发布失败。</p></li></ol></li><li><p>撤回已发布的版本</p><pre><code class="sh"> npm unpublish -f &lt;package name&gt;@&lt;package version&gt;</code></pre><ol><li><p>包发布后的 72 小时内，可以撤回。</p></li><li><p>已撤回的版本，该版本号就不能再重新发布了，因为在 NPM 的仓库中已经有了记录。</p></li></ol></li><li><p>其它问题</p><ol><li><p>偶尔可能会看到如下错误:</p><pre><code class="sh"> no_perms Private mode enable, only admin can publish this module</code></pre><p> 解决办法：</p><pre><code class="sh"> npm config set registry http://registry.npmjs.org</code></pre></li><li><p>NPM 官方提供了发布的指导：<a href="https://docs.npmjs.com/misc/developers">https://docs.npmjs.com/misc/developers</a> ，如果遇到一些奇怪的问题，建议前往阅读。</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、准备工作&quot;&gt;&lt;a href=&quot;#一、准备工作&quot; class=&quot;headerlink&quot; title=&quot;一、准备工作&quot;&gt;&lt;/a&gt;一、准备工作&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 NPM 官网注册账号，&lt;a href=&quot;https://www.npmjs.com&quot;&gt;</summary>
      
    
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/categories/NPM/"/>
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>规范 git commit</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/git-commit/index/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/git-commit/index/</id>
    <published>2020-06-11T02:17:53.000Z</published>
    <updated>2021-03-26T08:29:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>如何让 <code>git commit</code> 提交时更加规范？例如：vue、angular，如下图。规范化地提交记录，会让将来的回溯查找更容易，也让其他人阅读起来更加简便。</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172081ff77566188?w=996&h=1021&f=png&s=251160" alt=""></p><p>最近读到一篇不错的文章（<a href="https://juejin.im/post/5e0c82a15188253a907111dc">你可能已经忽略的 git commit 规范</a>），吸取下养分，顺便做个记录。文章介绍得很清楚，建议阅读原文，不做额外赘述，以下为集成到项目的快速指南。</p><h2 id="快速指南"><a href="#快速指南" class="headerlink" title="快速指南"></a>快速指南</h2><p>使用到的工具 <a href="https://github.com/commitizen/cz-cli">commitizen</a>、<a href="https://github.com/typicode/husky">husky</a>、<a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a>，cz-conventional-changelog 是 angular 的 commit message 格式。</p><p>所有包不推荐 global 安装，而仅项目本地安装，方便多人开发时，减少其他人的额外操作。</p><ol><li><p>安装工具</p><pre><code class="bash"> yarn add commitizen cz-conventional-changelog -D</code></pre></li><li><p>在项目根目录的 package.json 中添加配置</p><pre><code class="json"> &#123;   &quot;scripts&quot;: &#123;     &quot;commit&quot;: &quot;git-cz&quot;   &#125;,   &quot;config&quot;: &#123;     &quot;commitizen&quot;: &#123;       &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;     &#125;   &#125; &#125;</code></pre><p> 官方推荐的是 global 安装 commitizen，然后执行 <code>commitizen init cz-conventional-changelog --yarn --dev --exact</code> 去自动添加 cz-conventional-changelog，自动在 package.json 中添加 config 配置，不太推荐这种方式。</p></li><li><p>使用</p><ul><li><p><code>git commit</code> 仍然是普通的 git 提交模式</p></li><li><p><code>yarn commit</code> 会执行交互式 commit 提交，在终端跟着提示一步步输入即可。</p></li></ul></li><li><p>限制每一次 <code>git commit</code> 都执行交互式提交</p><p> 如果想要更暴力一点，限制每一次 <code>git commit</code> 都自动执行规范化地提交，可以配置 git 提交的钩子，借助 husky 更方便一点（不用 husky 当然也可以）。</p><p> 先将 scripts 中配置的 commit 命令删除，不再需要了。</p><p> 安装 husky</p><pre><code class="bash"> yarn add husky -D</code></pre><p> 在 package.json 中增加配置</p><pre><code class="json"> &#123;   &quot;husky&quot;: &#123;     &quot;hooks&quot;: &#123;       &quot;prepare-commit-msg&quot;: &quot;exec &lt; /dev/tty &amp;&amp; git cz --hook || true&quot;     &#125;   &#125;, &#125;</code></pre><p> 有些时候可能不太需要所有的 commit 都执行规范化的提交流程，因此，推荐不要这么暴力限制，而是仅在关键性的提交步骤才执行。</p></li></ol><h2 id="在提交中支持表情符号"><a href="#在提交中支持表情符号" class="headerlink" title="在提交中支持表情符号"></a>在提交中支持表情符号</h2><p>如果想要在提交中使用一些表情符号，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172086dbf52c646f?w=2016&h=1570&f=png&s=405106" alt=""></p><p>可以借助 <a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a></p><p>安装</p><pre><code class="bash">yarn add gitmoji-cli -D</code></pre><p>使用方法：在提交时按照约定格式输入表情字符即可（左右两边英文冒号夹着字符，例如bug ☞ <code>:bug:</code>），提交后会自动被显示，示例：</p><pre><code class="bash">git commit -m &quot;fix(src): :bug: 修复列表显示问题&quot;</code></pre><p>如果想要查看所有的表情符号及介绍，可以<a href="https://gitmoji.carloscuesta.me/">去官方文档查阅</a>，也可以全局安装</p><p><code>npm i -g gitmoji-cli</code></p><p>执行 <code>gitmoji -l</code> 命令在终端查看。</p><h2 id="常见的-commit-类型"><a href="#常见的-commit-类型" class="headerlink" title="常见的 commit 类型"></a>常见的 commit 类型</h2><ul><li>feat: 新增feature</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档，如readme.md</li><li>style: 仅仅是对格式进行修改，如逗号、缩进、空格等。不改变代码逻辑。</li><li>refactor: 代码重构，没有新增功能或修复bug</li><li>perf: 优化相关，如提升性能、用户体验等。</li><li>test: 测试用例，包括单元测试、集成测试。</li><li>chore: 改变构建流程、或者增加依赖库、工具等。</li><li>revert: 版本回滚</li></ul><h2 id="自己手写-commit-的推荐写法"><a href="#自己手写-commit-的推荐写法" class="headerlink" title="自己手写 commit 的推荐写法"></a>自己手写 commit 的推荐写法</h2><p>如果通过简单的 git commit -m “” 提交，你大概可以这样写：</p><pre><code class="bash">git commit -m &quot;feat(player): 播放功能开发完成&quot;</code></pre><p>引号内即 commit 的 message:</p><ul><li>feat 表明本次提交的类型</li><li>括号内容是本次代码的影响目录/文件</li><li>冒号后面是本次提交的简短描述（冒号后面推荐来个空格）  </li></ul><p>加点表情符号（当然，你要先安装 gitmoji-cli）：</p><pre><code class="bash">git commit -m &quot;feat(player): :rocket: 播放功能开发完成&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何让 &lt;code&gt;git commit&lt;/code&gt; 提交时更加规范？例如：vue、angular，如下图。规范化地提交记录，会让将来的回溯查找更容易，也让其他人阅读起来更加简便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.i</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Hook 提交时修改版本号</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/check-version/index/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/check-version/index/</id>
    <published>2020-06-11T02:07:48.000Z</published>
    <updated>2021-03-26T08:29:02.141Z</updated>
    
    <content type="html"><![CDATA[<p>前端项目在 Git 提交时，往往会遗忘更新项目根目录的 package.json 文件的 version，通常不修改也不会有啥问题，但对于强迫症来说，不能忍！咱要改掉它……</p><h4 id="编写一个简单的-node-脚本-check-version-js"><a href="#编写一个简单的-node-脚本-check-version-js" class="headerlink" title="编写一个简单的 node 脚本 check-version.js"></a>编写一个简单的 node 脚本 <code>check-version.js</code></h4><p>先安装几个依赖包 <code>yarn add inquirer chalk child_process -D</code></p><pre><code class="js">// /scripts/check-version.jsconst inquirer = require(&#39;inquirer&#39;)const chalk = require(&#39;chalk&#39;)const &#123; exec &#125; = require(&#39;child_process&#39;)const &#123; name: projectName, version: versionCurrent &#125; = require(&#39;../package&#39;)const regVersion = /^[1-9]&#123;1&#125;\d*\.\d+\.\d+$/ // 示例: 1.0.0// const regVersion = /^\d+\.\d+\.\d+$/ // 示例: 0.0.1 / 1.0.1// const regVersion = /^\d+\.\d+\.\d+(-beta.?\d*)?$/ // 示例: 1.0.3 / 0.0.1-beta / 1.0.0-beta.3console.log(&#39;\n&#39;)// 确认 package.json 版本号inquirer  .prompt([    &#123;      type: &#39;input&#39;,      name: &#39;version&#39;,      message: `请确认 $&#123;projectName&#125;/package.json/version 版本号（当前：$&#123;versionCurrent&#125;）：\n`,      default: versionCurrent,      validate(version) &#123;        // 校验版本号的格式        if (!regVersion.test(version)) &#123;          console.log(chalk.yellow(&#39;输入的版本号无效，请检查格式（示例：1.0.0、2.3.2）&#39;))          return false        &#125;        return true      &#125;,    &#125;,  ])  .then((&#123; version: versionNew &#125;) =&gt; &#123;    if (versionNew !== versionCurrent) &#123;      // 更新 package.json version，更新时不自动生成 tag      command(`npm --no-git-tag-version version $&#123;versionNew&#125;`, &#123;&#125;, (error, stdout, stderr) =&gt; &#123;        if (!error) &#123;          console.log(            chalk.green(              `\n$&#123;projectName&#125; 版本号（项目根目录下的 package.json/version）更新成功，version: $&#123;versionNew&#125; ！`,            ),          )          command(            `git add package.json &amp;&amp; git commit -m &#39;ci(package.json): 更新项目版本号为：$&#123;versionNew&#125;&#39;`,          )          console.log(`\n`)          process.exit(0)        &#125; else &#123;          console.log(chalk.yellow(`\n更新版本号（$&#123;versionNew&#125;）失败了~\n`))          process.exit(1)        &#125;      &#125;)    &#125; else &#123;      console.log(chalk.green(`\n本次版本号未做修改，version: $&#123;versionNew&#125; ！\n`))    &#125;  &#125;)function command(cmd, options, callback) &#123;  console.log(&#39;\n&#39;)  console.log(chalk.cyan(cmd.toString()))  return exec(cmd, &#123; ...options &#125;, callback)&#125;</code></pre><h4 id="配置-Git-钩子"><a href="#配置-Git-钩子" class="headerlink" title="配置 Git 钩子"></a>配置 Git 钩子</h4><ol><li><p>先安装 <code>husky</code>，用于管理 git 钩子，当然，使用原生的也可以。</p><pre><code class="bash"> yarn add husky -D</code></pre></li><li><p>在项目的 package.json 文件中增加以下配置：</p><pre><code class="json"> &quot;husky&quot;: &#123;   &quot;hooks&quot;: &#123;     &quot;post-commit&quot;: &quot;exec &lt; /dev/tty &amp;&amp; node scripts/check-version.js&quot;   &#125; &#125;,</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>完成以上配置后，后续在执行 git commit 提交代码时，会自动在终端弹出交互，提示修改 package.json 文件的 version，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729d6b37f7e5254?w=1326&h=348&f=png&s=55796" alt=""></p><p>如果不需要修改直接敲击 Enter 跳过，需要则输入新的版本号，会自动执行命令修改 package.json 文件的 version，并自动提交刚刚的修改，接下来 <code>git push</code> 推送代码即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端项目在 Git 提交时，往往会遗忘更新项目根目录的 package.json 文件的 version，通常不修改也不会有啥问题，但对于强迫症来说，不能忍！咱要改掉它……&lt;/p&gt;
&lt;h4 id=&quot;编写一个简单的-node-脚本-check-version-js&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
  </entry>
  
</feed>
