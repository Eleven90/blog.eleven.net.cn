<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Charles 抓包/代理 websocket 请求</title>
      <link href="/2021/05/29/charles/websocket/"/>
      <url>/2021/05/29/charles/websocket/</url>
      
        <content type="html"><![CDATA[<p>Charles 中如何抓包、代理 websocket 请求？过程有些复杂、坑点颇多，这里提供一份可用的方案。</p><p>请先确保你的 charles 能够抓到浏览器的请求，通常你可能需要注意以下几类问题：</p><ul><li>确保已勾选 charles 的 <code>Proxy - macOS Proxy</code> 选项</li><li>浏览器推荐设置为“系统代理”，如果使用了某些浏览器的代理插件，请记得切换</li><li>是否已安装好 https 证书？</li><li>如果有使用某些 VPN 代理工具，可能会存在代理冲突。如果遇到了抓不到请求的问题，推荐先关掉 VPN 工具，随后重启 charles（重启比较重要，它会重置系统的网络代理配置）</li></ul><p>如果还有问题，推荐阅读这篇使用指南 ☞ <a href="https://blog.csdn.net/mxw2552261/article/details/78645118">传送门</a>。</p><p>保证能正常抓到请求，再继续向下去看怎么抓取 websocket，当前使用的 charles 版本是 v4.6.1。</p><h2 id="charles-需要开启若干设置"><a href="#charles-需要开启若干设置" class="headerlink" title="charles 需要开启若干设置"></a>charles 需要开启若干设置</h2><p>1、打开 Proxy - Proxy Settings，勾选 Enable SOCKS proxy，默认配置不必修改，如下图：</p><p><img src="/imgs/charles_01.png" alt=""></p><p>2、在 Proxy - Proxy Settings - macos 面板中，确保勾选 Use SOCKS proxy，如下图：</p><p><img src="/imgs/charles_02.png" alt=""></p><h2 id="Mac-的网络设置中勾选若干项"><a href="#Mac-的网络设置中勾选若干项" class="headerlink" title="Mac 的网络设置中勾选若干项"></a>Mac 的网络设置中勾选若干项</h2><p>确保勾选了 SOCKS 选项，如下图：</p><p><img src="/imgs/mac_01.png" alt=""></p><p><img src="/imgs/mac_02.png" alt=""></p><p>SOCKS 代理的端口 8889 是 charles 代理 websocket 的默认端口，一般情况下不要去修改它。</p><p>以上工作都完成，那么你应该可以愉快地抓取、代理 websockt 请求了。</p>]]></content>
      
      
      <categories>
          
          <category> Charles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple M1 芯片问题汇总</title>
      <link href="/2021/04/14/mac/command/"/>
      <url>/2021/04/14/mac/command/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Rosetta-打开"><a href="#使用-Rosetta-打开" class="headerlink" title="使用 Rosetta 打开"></a>使用 Rosetta 打开</h2><p><a href="https://www.macwk.com/article/apple-silicon-m1-application-crash-repair">https://www.macwk.com/article/apple-silicon-m1-application-crash-repair</a></p><h2 id="nvm-终端切换-x86-arm"><a href="#nvm-终端切换-x86-arm" class="headerlink" title="nvm 终端切换 x86/arm"></a>nvm 终端切换 x86/arm</h2><pre><code class="zsh"># Check what version you&#39;re running:$ node --versionv14.15.4# Check architecture of the `node` binary:$ node -p process.archarm64# This confirms that the arch is for the M1 chip, which is causing the problems.# So we need to uninstall it.# We can&#39;t uninstall the version we are currently using, so switch to another version:$ nvm install v12.20.1# Now uninstall the version we want to replace:$ nvm uninstall v14.15.4# Launch a new zsh process under the 64-bit X86 architecture:$ arch -x86_64 zsh# Install node using nvm. This should download the precompiled x64 binary:$ nvm install v14.15.4# Now check that the architecture is correct:$ node -p process.archx64# It is now safe to return to the arm64 zsh process:$ exit# We&#39;re back to a native shell:$ archarm64# And the new version is now available to use:$ nvm use v14.15.4Now using node v14.15.4 (npm v6.14.10)</code></pre>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 非常规问题记录</title>
      <link href="/2021/04/07/git/questions/"/>
      <url>/2021/04/07/git/questions/</url>
      
        <content type="html"><![CDATA[<h2 id="与-fork-的上游仓库保持同步"><a href="#与-fork-的上游仓库保持同步" class="headerlink" title="与 fork 的上游仓库保持同步"></a>与 fork 的上游仓库保持同步</h2><p>一般有 3 种办法可用：</p><ol><li>命令行同步（安全，推荐）</li></ol><pre><code class="zsh">git remote -v# 将上游仓库添加进来git remote add upstream git@github.com:xxx/xxx.git# 拉取更新git fetch upstream# 合并过来git merge upstream/mastergit push origin master</code></pre><p>若干可以注意的地方，如下图：</p><p><img src="/imgs/git_fetch_fork_repo.png" alt=""></p><ol start="2"><li><p>借助第三方库：<a href="https://github.com/wei/pull">https://github.com/wei/pull</a>  (如果自己有修改，会被覆盖。所以，比较适合仅参与 PR 的项目同步)</p></li><li><p>借助机器人程序 Backstroke：<a href="https://github.com/backstrokeapp/server">https://github.com/backstrokeapp/server</a></p></li></ol><h2 id="提示-hosts-问题"><a href="#提示-hosts-问题" class="headerlink" title="提示 hosts 问题"></a>提示 hosts 问题</h2><pre><code class="zsh">Warning:Permanently added the RSA host key for IP address &#39;13.229.188.59&#39; to the list of known hosts.</code></pre><p>遇到这种提示，多半是因为新机器刚配置的 git，或者常用的远程仓库更换了域名、IP 等。</p><p>可以将对应的域名、IP 配置进去，例如，将 github.com 添加进去，示例：</p><pre><code class="zsh">vi /etc/hostsinsert 13.229.188.59 github.com</code></pre><p>或者，删除 host 校验</p><pre><code class="zsh">rm -rf ~/.ssh/known_hosts # 删除后重新操作即可</code></pre><h2 id="Enter-passphrase-for-key-每次都需要输入密码"><a href="#Enter-passphrase-for-key-每次都需要输入密码" class="headerlink" title="Enter passphrase for key 每次都需要输入密码"></a>Enter passphrase for key 每次都需要输入密码</h2><pre><code class="zsh">ssh-add ~/.ssh/id_rsa</code></pre><h2 id="设置某文件、目录不被跟踪"><a href="#设置某文件、目录不被跟踪" class="headerlink" title="设置某文件、目录不被跟踪"></a>设置某文件、目录不被跟踪</h2><pre><code class="zsh">git update-index --assume-unchanged &lt;PATH&gt;</code></pre><p>对应的，允许某文件、目录被跟踪</p><pre><code class="zsh">git update-index --no-assume-unchanged &lt;PATH&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn workspaces 依赖安装报错</title>
      <link href="/2021/04/07/yarn/workspaces-version/"/>
      <url>/2021/04/07/yarn/workspaces-version/</url>
      
        <content type="html"><![CDATA[<p>yarn workspaces 结构的项目，在执行命令安装子包依赖时，可能会看到如下错误：</p><pre><code class="zsh">Failed to install dependencies in workspace: expected workspace package to exist</code></pre><p>yarn issues 下的相关问题讨论：<a href="https://github.com/yarnpkg/yarn/issues/7807">https://github.com/yarnpkg/yarn/issues/7807</a></p><p>目前比较简单的处理办法是降级 yarn 到 v1.18.0</p><pre><code class="zsh">yarn policies set-version 1.18.0</code></pre><p>后续还需要等待 yarn 官方来解决此问题。</p>]]></content>
      
      
      <categories>
          
          <category> Yarn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yarn </tag>
            
            <tag> Yarn Workspaces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「转」H5直播流原理与实践方案</title>
      <link href="/2021/03/28/video/live/"/>
      <url>/2021/03/28/video/live/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自 DuPei 同学的文档，这是比较全面的方案调研，转载分享给更多人，待将来需要时细细研究。</p></blockquote><h2 id="HLS-方案"><a href="#HLS-方案" class="headerlink" title="HLS 方案"></a>HLS 方案</h2><p>HLS 全称 HTTP Live Streaming，顾名思义是一个基于 HTTP 的流媒体传输协议。是由苹果公司提出，在苹果家族的整个产品都得到了比较好的支持，后来谷歌在 Chrome 浏览器和移动端浏览器也进行了原生支持，所以目前无论你是在 PC 还是移动端的浏览器基本都原生支持 HLS 协议进行播放视频，算是一个在移动端比较好的跨平台方案，同时微信内嵌的浏览器也都是原生支持的。</p><p>它允许用户从不同的备用源以不同的速率下载同样的资源片段。允许流媒体会话适应不同的数据速率。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>它的工作原理是把整个流切分成一片片小的基于 HTTP 的文件来下载。<br>浏览器使用的是 m3u8 文件，可以简单的认为 m3u8 就是包含多个 ts 文件的播放列表。播放器按顺序逐个播放，全部放完再请求一下 m3u8 文件，获得包含最新 ts 文件的播放列表继续播，周而复始。整个直播过程就是依靠一个不断更新的 m3u8 和一堆小的 ts 文件组成，m3u8 必须动态更新，ts 可以走 CDN。</p><p><img src="/imgs/video_live_hls.png" alt=""></p><h3 id="流说明"><a href="#流说明" class="headerlink" title="流说明"></a>流说明</h3><p>切片流，需要不断去请求新的 ts 文件才能续播。</p><ul><li>视频的封装格式是 TS。</li><li>视频的编码格式为 H264,音频编码格式为 MP3、AAC 或者 AC-3。</li><li>除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）</li></ul><p>m3u8 文件包含的内容如下：</p><ul><li>EXTM3U<br>每一个 m3u8 文件开头必须为这个 tag，用作标示。</li><li>EXT-X-VERSION<br>用于标示版本，当前版本为 3，有且只能有一个，默认为 1。</li><li>EXT-X-TARGETDURATION<br>每一片的最大长度，部分 iphone 设备此参数不正确会导致无法播放。</li><li>EXT-X-MEDIA-SEQUENCE<br>切片的开始序号，且每一片的序号具有唯一性，相邻序号递增以保持流的连续性。</li><li>EXTINF<br>切片的实际时长。</li><li>EXT-X-PLAYLIST-TYPE<br>类型</li><li>EXT-X-ENDLIST<br>结束符号。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性很不错，尤其是在移动端，可作为兜底方案。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>延时比较大。由于 HLS 协议本身的切片原理，基本延迟都在 10s 以上。</li><li>文件碎片，ts 切片较小，会造成海量文件，对存储和缓存都有一定的挑战。</li></ol><h2 id="HTTP-FLV-方案"><a href="#HTTP-FLV-方案" class="headerlink" title="HTTP FLV 方案"></a>HTTP FLV 方案</h2><p>HTTP-FLV 即将流媒体数据封装成 FLV 格式，然后通过 HTTP 协议传输给客户端。</p><p>播放的能力基于 Media Source Extensions(MSE)，是一个 W3C 草案，MSE 扩展了 HTML5 的 Video 和 Audio 标签能力，允许开发者通过 JS 来从服务端拉流提供到 HTML5 的 Video 和 Audio 标签进行播放。</p><p><a href="https://caniuse.com/?search=Media%20Source%20Extensions">目前 MSE 的兼容情况</a></p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>MSE 目前支持的视频封装格式是 MP4，支持的视频编码是 H.264 和 MPEG4，支持的音频编码是 AAC 和 MP3。<br>封装格式的处理</p><ol><li>从服务端拉裸流(flv)过来，在前端将 flv 合成 MP4 片段进行播放。</li><li>在服务端提前转封装好成 MP4 格式传输，在前端直接通过 MSE 接口来播放。</li></ol><h3 id="流说明-1"><a href="#流说明-1" class="headerlink" title="流说明"></a>流说明</h3><p>连续流。</p><p>一般方案都是服务端经摄像头推流转成 FLV，然后客户端拉流，拉过来的流解封装为 FLV，然后再转成 MP4 片段，再经由 MSE 播放即可。<br>这个解封装和转为 mp4 格式的过程，<a href="https://github.com/bilibili/flv.js">flv.js</a> 帮忙实现了。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>延时低。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>移动端的兼容性不好，iOS Safari 浏览器没有支持，部分低版本的 iOS 微信端也不支持。</p><h2 id="RTMP-方案"><a href="#RTMP-方案" class="headerlink" title="RTMP 方案"></a>RTMP 方案</h2><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。</p><p>基于 TCP 协议传输，这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，<strong>但无法支持移动端 WEB 播放是它的硬伤</strong>。</p><p>浏览器端，HTML5 video 标签无法播放 RTMP 协议的视频，可以通过 video.js 来实现。<a href="https://blog.csdn.net/impingo/article/details/103077380?spm=1001.2014.3001.5502">https://blog.csdn.net/impingo/article/details/103077380?spm=1001.2014.3001.5502</a></p><h2 id="以上三种方案比较"><a href="#以上三种方案比较" class="headerlink" title="以上三种方案比较"></a>以上三种方案比较</h2><table><thead><tr><th></th><th>Http flv</th><th>rtmp</th><th>hls</th></tr></thead><tbody><tr><td>传输协议</td><td>http</td><td>tcp</td><td>http</td></tr><tr><td>视频封装格式</td><td>flv</td><td>Flv tag</td><td>ts</td></tr><tr><td>延时</td><td>低</td><td>低</td><td>高</td></tr><tr><td>数据分段</td><td>连续流</td><td>连续流</td><td>切片文件</td></tr><tr><td>Html5 播放</td><td>可通过 h5 解封数据包播放 flv.js</td><td>不支持</td><td>可通过 h5 解封数据包播放 hls.js</td></tr></tbody></table><h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><h3 id="WebRTC-方案"><a href="#WebRTC-方案" class="headerlink" title="WebRTC 方案"></a>WebRTC 方案</h3><p>WebRTC 是一整套 API，其中一部分供 Web 开发者使用，另外一部分属于要求浏览器厂商实现的接口规范。WebRTC 解决诸如客户端流媒体发送、点对点通信、视频编码等问题。<br>桌面浏览器对 WebRTC 的支持较好，WebRTC 也很容易和 Native 应用集成。</p><h3 id="WebSocket-FLV"><a href="#WebSocket-FLV" class="headerlink" title="WebSocket-FLV"></a>WebSocket-FLV</h3><p>基于 WebSocket 传输 FLV，依赖浏览器支持播放 FLV。<br>WebSocket 建立在 HTTP 之上，建立 WebSocket 连接前还要先建立 HTTP 连接。</p><h3 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h3><p>基于 UDP，延迟 1 秒，浏览器不支持。</p><h2 id="清晰度切换支持"><a href="#清晰度切换支持" class="headerlink" title="清晰度切换支持"></a>清晰度切换支持</h2><p><a href="https://cloud.tencent.com/document/product/454/7503#.E5.8A.9F.E8.83.BD.E4.BB.8B.E7.BB.8D">清晰度切换支持</a></p><p><strong>播放器本身是没有能力去改变视频清晰度的</strong>，视频源只有一种清晰度，称之为原画，而原画视频的编码格式和封装格式多种，Web 端无法支持播放所有的视频格式，如点播支持以 H.264 为视频编码，MP4 和 FLV 为封装格式的视频。</p><p>多清晰度的实现依赖于服务端，进行实时转码，分出多路转码后的视频。</p>]]></content>
      
      
      <categories>
          
          <category> Video </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直播 </tag>
            
            <tag> Video </tag>
            
            <tag> Live </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何管理应用内的请求?</title>
      <link href="/2021/03/27/react/query/"/>
      <url>/2021/03/27/react/query/</url>
      
        <content type="html"><![CDATA[<p>如何管理应用内的接口请求？</p><p>这是一个值得讨论的问题，涉及如下若干方面：</p><ol><li>避免多次调用同一个请求（不同页面或不同组件）？</li><li>失败了自动重试？</li><li>切换浏览器 tab 返回页面时，自动发送请求更新数据？</li><li>列表滚动位置恢复？</li><li>…….</li></ol><p>这些问题可以在以下几个社区方案里找到答案（react-query 似乎更胜一筹）：</p><ul><li>reacrt-query：<a href="https://zhuanlan.zhihu.com/p/261146977">https://zhuanlan.zhihu.com/p/261146977</a></li><li>swr：<a href="https://swr.vercel.app/zh-CN">https://swr.vercel.app/zh-CN</a></li><li>ahooks/useRequest：<a href="https://ahooks.js.org/zh-CN/hooks/async">https://ahooks.js.org/zh-CN/hooks/async</a></li></ul><p>许多人会将多处使用的接口数据，存储到 Redux 等全局状态去管理，以减少重复的请求。理论上来说这是不合理的，状态管理会因此而变得混乱、臃肿，也给代码编写带来了额外的负担。</p><p>使用以上方案后，类库内部自动管理接口数据的状态，暂且称之为“服务端状态”，在任意的页面、组件都可以保持相同的 Hooks 方式调用，而全局只会发送一次请求，因此，状态管理需要存储的数据可以大幅减少。除此之外，还有自动重试、切屏更新数据等强大的封装功能，是日常应用开发的利器。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Babel 编译误伤 core-js？</title>
      <link href="/2021/03/26/core-js/babel-compile/"/>
      <url>/2021/03/26/core-js/babel-compile/</url>
      
        <content type="html"><![CDATA[<p>一个不太常见，但很重要的 core-js bug 讨论：<a href="https://github.com/zloirock/core-js/issues/514">https://github.com/zloirock/core-js/issues/514</a></p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>core-js 是 es3 的代码，应当是不需要 babel 编译的，但是，因为某种原因（暂不清楚），babel 会对 core-js 进行处理，并且会影响其中的代码，进而会发现 Symbol 在 Android 6.0 等低版本浏览器的兼容性出问题。</p><p>在移动端页面，小伙伴实际遭遇到了这种现象，依赖的第三方包使用了 Symbol 语法，即使引入全量的 core-js，依然无法解决兼容性报错问题，最终小伙伴追踪到了上方的 github issues。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>暂时需要手动将 core-js 添加到 <code>babel-loader</code> 的 <code>exclude</code> 配置中，指定 babel 不要去处理它。</p><pre><code class="js">/** * Babel 编译时，会处理 core-js（未来可能会被修复）， * 导致 polyfill 内部代码发生了变化，产生一些微小的影响，如 Symbol 问题。 * 暂时我们手动声明略过。 * https://github.com/zloirock/core-js/issues/514 * https://github.com/rails/webpacker/pull/2031 */exclude: [  /node_modules[\\/]core-js/,],</code></pre>]]></content>
      
      
      <categories>
          
          <category> Babel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无 eject 重写 CRA 配置 — Craco 详解</title>
      <link href="/2020/09/11/cra/craco/"/>
      <url>/2020/09/11/cra/craco/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内置 craco 扩展配置的 CRA Template，可直接使用。<br>TS 版本：<a href="https://www.npmjs.com/package/@eleven.fe/cra-template-typescript">@eleven.fe/cra-template-typescript</a><br>ES 版本：<a href="https://www.npmjs.com/package/@eleven.fe/cra-template">@eleven.fe/cra-template</a>  </p></blockquote><p>使用 CRA 脚手架创建的项目，如果想要修改编译配置，通常可能会选择 <code>npm run eject</code> 弹出配置后魔改。但是，eject 是不可逆操作，弹出配置后，你将无法跟随官方的脚步去升级项目的 react-scripts 版本。</p><p>如果想要无 eject 重写 CRA 配置，一般可以有以下几种方式</p><ol><li>通过 CRA 官方支持的 <code>--scripts-version</code> 参数，创建项目时使用自己重写过的 react-scripts 包</li><li>使用 <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> + <a href="https://github.com/arackaf/customize-cra">customize-cra</a> 组合覆盖配置</li><li>使用 <a href="https://github.com/gsoft-inc/craco">craco</a> 覆盖配置</li></ol><p>第一种方式很棒，但这里暂时不做讨论，感兴趣的可以从下方链接了解更多：</p><ol><li>CRA 官方的介绍：<a href="https://create-react-app.dev/docs/alternatives-to-ejecting/">Alternatives to Ejecting</a></li><li><a href="https://auth0.com/blog/how-to-configure-create-react-app/">Customizing create-react-app: How to Make Your Own Template</a></li></ol><p>第二种方式相对第三种略复杂一些，并且我注意到 AntDesign 官方也开始推荐 <a href="https://github.com/gsoft-inc/craco">craco</a> 了，这里详细讨论一下第三种 <a href="https://github.com/gsoft-inc/craco">craco</a> 的使用，经过项目的实测，用起来还算顺手。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol><li><p>安装包</p><pre><code class="sh"> yarn add @craco/craco</code></pre></li><li><p>项目根目录创建 <code>craco.config.js</code> 文件</p><pre><code class="js"> /* craco.config.js */ module.exports = &#123;   ... &#125;</code></pre></li><li><p>修改 package.json 的 scripts 命令</p><pre><code class="json"> /* package.json */ &quot;scripts&quot;: &#123; -   &quot;start&quot;: &quot;react-scripts start&quot;, +   &quot;start&quot;: &quot;craco start&quot;, -   &quot;build&quot;: &quot;react-scripts build&quot;, +   &quot;build&quot;: &quot;craco build&quot; -   &quot;test&quot;: &quot;react-scripts test&quot;, +   &quot;test&quot;: &quot;craco test&quot; &#125;</code></pre></li></ol><p>基础的配置到此完成了，接下来是处理各种配置的覆盖，完整的 craco.config.js 配置文件结构，可以在 craco 官方的文档中详细查询：<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a> 。</p><h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><p>@craco/craco 提供了 <code>whenDev、whenProd、whenTest、when</code> 函数，用于在书写 craco.config.js 配置文件时根据不同的编译环境确定配置，先看一下 craco 相关的源码：</p><pre><code class="js">function when(condition, fct, unmetValue) &#123;    if (condition) &#123;        return fct();    &#125;    return unmetValue;&#125;function whenDev(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;development&quot;, fct, unmetValue);&#125;function whenProd(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;production&quot;, fct, unmetValue);&#125;function whenTest(fct, unmetValue) &#123;    return when(process.env.NODE_ENV === &quot;test&quot;, fct, unmetValue);&#125;module.exports = &#123;    when,    whenDev,    whenProd,    whenTest&#125;;</code></pre><ul><li><p><code>whenDev、whenProd、whenTest</code> 分别对应的是 <code>process.env.NODE_ENV</code> 的 3 种值（<code>development</code>、<code>production</code>、<code>test</code>），接收两个参数：</p><ul><li>第一个参数是 function，对应该编译环境下，执行函数，函数一般应当将需要的配置作为返回值。</li><li>第二个参数是默认值，非指定编译环境时，返回该默认值。</li></ul></li><li><p><code>when</code> 是区分环境的万金油函数，接收 3 个参数：</p><ul><li>第一个参数是判断的变量。</li><li>第二个参数是 function，参数一的变量为 true 时，执行该函数，函数一般应当将需要的配置作为返回值。</li><li>第三个参数是默认值，参数一的变量为 false 时，返回该默认值。</li></ul></li></ul><p>引用方式：</p><pre><code class="js">const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)</code></pre><p>下方的示例中有多处使用，可以参照了解其用途。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>craco 有提供一些 <a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">plugins</a>，集成了诸多功能，让覆盖配置变得更加容易。</p><p>除此之外，则需要我们对 webpack 的配置有一定的了解，根据 craco.config.js 的文件结构去增加配置。</p><h3 id="通过-configure-函数扩展-webpack-配置"><a href="#通过-configure-函数扩展-webpack-配置" class="headerlink" title="通过 configure 函数扩展 webpack 配置"></a>通过 configure 函数扩展 webpack 配置</h3><p>几乎所有的 webpack 配置均可以在 configure 函数中读取、覆盖，webpack 详细的配置参数结构可以查阅 webpack 官方的文档：<a href="https://webpack.js.org/configuration/">https://webpack.js.org/configuration/</a> 。</p><p>需要注意一点，configure 既可以定义为对象，也可以定义为函数，使用过程中，我发现二者是互斥的关系。这里推荐使用函数形式，因为当我想要覆盖 <code>mini-css-extract-plugin</code> 的配置时，发现对象形式的 configure 定义，不能达到目的。</p><p>configure 可以扩展所有的 webpack 配置，你可以将所有的配置都在 configure 中写完，但是，craco 提供了若干快捷的方式去定义指定的配置，例如：babel、alias、webpack 的 plugins 等。因此，推荐有快捷的方式尽量用快捷方式，搞不定的才放到 configure 中去定义。</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    /**     * 重写 webpack 任意配置     *  - 与直接定义 configure 对象方式互斥     *  - 几乎所有的 webpack 配置均可以在 configure 函数中读取，然后覆盖     */    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;      // 修改 output      webpackConfig.output = &#123;        ...webpackConfig.output,        ...&#123;          filename: whenDev(() =&gt; &#39;static/js/bundle.js&#39;, &#39;static/js/[name].js&#39;),          chunkFilename: &#39;static/js/[name].js&#39;,        &#125;,      &#125;      // 关闭 devtool      webpackConfig.devtool = false      // 配置扩展扩展名      webpackConfig.resolve.extensions = [        ...webpackConfig.resolve.extensions,        ...[&#39;.scss&#39;, &#39;.less&#39;],      ]      // 配置 splitChunks      webpackConfig.optimization.splitChunks = &#123;        ...webpackConfig.optimization.splitChunks,        ...&#123;          chunks: &#39;all&#39;,          name: true,        &#125;,      &#125;      // 覆盖已经内置的 plugin 配置      webpackConfig.plugins.map((plugin) =&gt; &#123;        whenProd(() =&gt; &#123;          if (plugin instanceof MiniCssExtractPlugin) &#123;            Object.assign(plugin.options, &#123;              filename: &#39;static/css/[name].css&#39;,              chunkFilename: &#39;static/css/[name].css&#39;,            &#125;)          &#125;        &#125;)        return plugin      &#125;)      return webpackConfig    &#125;,  &#125;&#125;</code></pre><h3 id="扩展-babel-配置"><a href="#扩展-babel-配置" class="headerlink" title="扩展 babel 配置"></a>扩展 babel 配置</h3><p>虽然可以在 configure 中定义 babel 配置，但 craco 也提供了快捷的方式单独去书写，添加 <code>@babel/preset-env</code> 配置示例如下：</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;    presets: [      [        &#39;@babel/preset-env&#39;,        &#123;          modules: false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等          useBuiltIns: &#39;entry&#39;, // browserslist环境不支持的所有垫片都导入          // https://babeljs.io/docs/en/babel-preset-env#usebuiltins          // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md          corejs: &#123;            version: 3, // 使用core-js@3            proposals: true,          &#125;,        &#125;,      ],    ],    plugins: [    ],  &#125;,&#125;</code></pre><p>更详细的 babel 相关配置，推荐我之前整理的：<a href="https://webpack.eleven.net.cn/content/babel/">https://webpack.eleven.net.cn/content/babel/</a> 。</p><h3 id="扩展-webpack-alias（别名）"><a href="#扩展-webpack-alias（别名）" class="headerlink" title="扩展 webpack alias（别名）"></a>扩展 webpack alias（别名）</h3><p>虽然可以在 configure 中定义 alias，但 craco 也提供了快捷的方式单独去书写。</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;    &#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,  &#125;&#125;</code></pre><p>这里有一个坑点，如果你使用的是 cra 创建的 typescript 项目，添加完 alias 后，你还需要在 tsconfig.json 文件中新增配置，否则会提示出错。并且，新版本 cra 创建的项目，在编译时会自动格式化 tsconfig.json，你向里面添加的若干配置，可能会自动被清除掉。</p><p>怎么办？这里寻找到一个机智的办法，利用 tsconfig 的 extends 参数去扩展需要的配置。</p><p>tsconfig.json</p><pre><code class="json">&#123;  &quot;extends&quot;: &quot;./tsconfig.edit.json&quot;,  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;lib&quot;: [      &quot;dom&quot;,      &quot;dom.iterable&quot;,      &quot;esnext&quot;    ],    &quot;allowJs&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;strict&quot;: true,    &quot;forceConsistentCasingInFileNames&quot;: true,    &quot;module&quot;: &quot;esnext&quot;,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;resolveJsonModule&quot;: true,    &quot;isolatedModules&quot;: true,    &quot;noEmit&quot;: true,    &quot;jsx&quot;: &quot;react&quot;  &#125;,  &quot;include&quot;: [    &quot;src&quot;  ]&#125;</code></pre><p>tsconfig.edit.json</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;src/*&quot;]    &#125;  &#125;&#125;</code></pre><p>通过继承的方式，添加如上配置，alias 修改即可完成。</p><p>另外，craco 也提供了一个 plugin 专门用于修改 alias，以及处理 tsconfig 的问题，<a href="https://github.com/risenforces/craco-alias">传送门</a>，该页面下方的 Examples 中，详细说明了 tsconfig 的方案，推荐使用。</p><h3 id="新增-webpack-plugins"><a href="#新增-webpack-plugins" class="headerlink" title="新增 webpack plugins"></a>新增 webpack plugins</h3><p>如果想要新增一些 webpack plugins，可以直接在与 configure 平级的位置添加。当然，你在 configure 里添加也可以，但不推荐。</p><p>需要注意的是，如果你想修改内置的某些 webpack plugin 参数，必须到 configure 里去修改，示例见上方的 configure 介绍。</p><p>示例如下：</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)const CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)const &#123; BundleAnalyzerPlugin &#125; = require(&#39;webpack-bundle-analyzer&#39;)module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;    &#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,    plugins: [ // 新增 webpack plugin      // 新增模块循环依赖检测插件      ...whenDev(        () =&gt; [          new CircularDependencyPlugin(&#123;            exclude: /node_modules/,            include: /src/,            failOnError: true,            allowAsyncCycles: false,            cwd: process.cwd(),          &#125;),        ],        [],      ),      // 新增打包产物分析插件      ...whenProd(        () =&gt; [          // https://www.npmjs.com/package/webpack-bundle-analyzer          new BundleAnalyzerPlugin(&#123;            analyzerMode: &#39;static&#39;, // html 文件方式输出编译分析            openAnalyzer: false,            reportFilename: path.resolve(__dirname, `analyzer/index.html`),          &#125;),        ],        [],      ),    ],  &#125;&#125;</code></pre><h3 id="扩展-react-hot-loader"><a href="#扩展-react-hot-loader" class="headerlink" title="扩展 react-hot-loader"></a>扩展 react-hot-loader</h3><blockquote><p>CRA v4.0 开始已经内置了 fast refresh —— <a href="https://github.com/facebook/create-react-app/releases/tag/v4.0.0">https://github.com/facebook/create-react-app/releases/tag/v4.0.0</a> ，不必自己扩展 hot loader。</p></blockquote><p>常用的热更新方案 react-hot-loader，craco 提供了专门的 craco plugin（<a href="https://github.com/HasanAyan/craco-plugin-react-hot-reload">传送门</a>），配置如下：</p><pre><code class="sh">yarn add craco-plugin-react-hot-reload -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;)const reactHotReloadPlugin = require(&#39;craco-plugin-react-hot-reload&#39;)module.exports = &#123;  babel: &#123;  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [    // 新增 craco-plugin-react-hot-reload      ...whenDev(      () =&gt; [        &#123;          plugin: reactHotReloadPlugin,        &#125;,      ],      [],    ),  ]&#125;</code></pre><p>添加完配置，还需在入口文件中修改一下 render。</p><pre><code class="sh">yarn add react-hot-loader -D</code></pre><pre><code class="js">/* 入口 index.ts */import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;+ import &#123; hot &#125; from &#39;react-hot-loader&#39;+ import &#123; isDev &#125; from &#39;@/utils&#39; // isDev 你可以自己编写定义，例如：const isDev = process.env.NODE_ENV === &#39;development&#39;import App from &#39;./App&#39;+ const Root = isDev ? hot(module)(App) : App- ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))+ ReactDOM.render(&lt;Root /&gt;, document.getElementById(&#39;root&#39;))</code></pre><h3 id="比-react-hot-loader-更好的方案-craco-fast-refresh"><a href="#比-react-hot-loader-更好的方案-craco-fast-refresh" class="headerlink" title="比 react-hot-loader 更好的方案 craco-fast-refresh"></a>比 react-hot-loader 更好的方案 craco-fast-refresh</h3><blockquote><p>CRA v4.0 开始已经内置了 fast refresh —— <a href="https://github.com/facebook/create-react-app/releases/tag/v4.0.0">https://github.com/facebook/create-react-app/releases/tag/v4.0.0</a> ，不必自己扩展 hot loader。</p></blockquote><p>这是最近发现的新 craco plugin，相对于 react-hot-loader 好用得多，零配置，不需要修改项目代码，据说性能也更好。</p><pre><code class="sh">yarn add craco-fast-refresh -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev &#125; = require(&#39;@craco/craco&#39;)const fastRefreshCracoPlugin = require(&#39;craco-fast-refresh&#39;)module.exports = &#123;  babel: &#123;  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [      ...whenDev(      () =&gt; [        &#123;          plugin: fastRefreshCracoPlugin,        &#125;,      ],      [],    ),  ]&#125;</code></pre><h3 id="AntDesign-自定义主题-amp-按需加载"><a href="#AntDesign-自定义主题-amp-按需加载" class="headerlink" title="AntDesign 自定义主题 &amp; 按需加载"></a>AntDesign 自定义主题 &amp; 按需加载</h3><ul><li>在 bebel 配置中新增 <code>babel-plugin-import</code>，搞定 AntDesign 按需加载</li><li>新增 craco 提供的 plugin <code>craco-less</code>，搞定自定义主题</li></ul><pre><code class="sh">yarn add babel-plugin-import craco-less -D</code></pre><pre><code class="js">/* craco.config.js */const CracoLessPlugin = require(&#39;craco-less&#39;)module.exports = &#123;  babel: &#123;    plugins: [      // 配置 babel-plugin-import      [        &#39;import&#39;,        &#123;          libraryName: &#39;antd&#39;,          libraryDirectory: &#39;es&#39;,          style: &#39;css&#39;,        &#125;,        &#39;antd&#39;,      ],    ],  &#125;,  webpack: &#123;  &#125;,  // craco 提供的插件  plugins: [    // 配置 less      &#123;      plugin: CracoLessPlugin,      options: &#123;        lessLoaderOptions: &#123;          lessOptions: &#123;            modifyVars: &#123;              // 自定义主题（如果有需要，单独文件定义更好一些）              &#39;@primary-color&#39;: &#39;#1DA57A&#39;,            &#125;,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,  ]&#125;</code></pre><p>craco 也提供了专门的 plugin 来处理 antd 的集成（<a href="https://github.com/DocSpring/craco-antd">传送门</a>），与上方的配置方式有区别。从 github 的介绍中能够看到如下介绍：</p><p>craco-antd includes:</p><ul><li>Less (provided by craco-less)</li><li>babel-plugin-import to only import the required CSS, instead of everything</li><li>An easy way to customize the theme. Set your custom variables in ./antd.customize.less</li></ul><p>相对来讲使用会更简洁一些，推荐使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过项目中的试用，确实能够在不 eject 弹出配置的情况下，自定义所有的 cra 构建配置，因此，在后续的编码中，我应该还会继续使用。</p><p>上方是最近在项目中，使用到的一些配置，更多的使用方式建议通过阅读官方的文档（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md">传送门</a>）去了解，尤其需要详细了解 craco.config.js 文件的配置列表（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a>）。</p><p>有几点建议如下：</p><ol><li><p>craco 有提供一些好用的 plugin（<a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">传送门</a>），推荐优先考虑使用现成的插件去解决问题。</p><p> 注意 craco 的 plugin 与 webpack plugin 不是同一概念，二者配置的位置也不同。</p></li><li><p>webpack 相关的配置覆盖，优先使用 craco 提供的快捷方式去配置。</p><p> 解决不了的问题，在 configure 函数中配置，并且，推荐 configure 使用函数形式，而非对象形式。虽然，函数形式更复杂了一点，但是二者是互斥的，只好选择其中一种。</p></li></ol><p>最后，放一份完整的 craco.config.js 配置文件，方便参照。</p><blockquote><p>版本是 webpack v4、create-react-app v4，其它不同的版本，可能需要略加调整。</p></blockquote><pre><code class="js">/** * Craco 重写 CRA 配置 *  - GitHub：https://github.com/gsoft-inc/craco *  - 配置参数：https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview *  - 快速指南：https://blog.eleven.net.cn/2020/09/11/cra/craco/ * * Tips： *  1、区分 node 运行环境 —— NODE_ENV *    - whenDev ☞ process.env.NODE_ENV === &#39;development&#39; *    - whenTest ☞ process.env.NODE_ENV === &#39;test&#39; *    - whenProd ☞ process.env.NODE_ENV === &#39;production&#39; *  2、NODE_ENV 可以区分 node 运行环境，仅支持 development、test、production， *    自定义的 REACT_APP_BUILD_ENV 用于区分编译环境，支持 development、test、uat、production。 *  3、craco 有提供一些好用的 plugin（https://github.com/gsoft-inc/craco#community-maintained-plugins），推荐优先考虑使用现成的 craco plugin 去解决问题。 *  4、CRA 脚手架相关的配置覆盖，优先使用 craco 提供的快捷方式去配置。解决不了的问题，在 configure 函数中配置。 *    推荐 configure 配置使用函数形式，而非对象形式。虽然，函数形式更复杂了一点，但是二者是互斥的，只能选择其中一种。 */const path = require(&#39;path&#39;);const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;);const &#123; BundleAnalyzerPlugin &#125; = require(&#39;webpack-bundle-analyzer&#39;);const CracoLessPlugin = require(&#39;craco-less&#39;);const CracoScopedCssPlugin = require(&#39;craco-plugin-scoped-css&#39;);const CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;);const TsconfigPathsPlugin = require(&#39;tsconfig-paths-webpack-plugin&#39;);const vConsolePlugin = require(&#39;vconsole-webpack-plugin&#39;);const genericNames = require(&#39;generic-names&#39;);const antdTheme = require(&#39;./antd.theme&#39;);// 判断编译环境是否为生产const isBuildProd = process.env.REACT_APP_BUILD_ENV === &#39;production&#39;;// 判断 node 运行环境是否为 productionconst isProd = process.env.NODE_ENV === &#39;production&#39;;const isBuildAnalyzer = process.env.BUILD_ANALYZER === &#39;true&#39;;const removeFilenameHash = process.env.REMOVE_FILENAME_HASH === &#39;true&#39;;const shouldDropDebugger = process.env.SHOULD_DROP_DEBUGGER === &#39;true&#39;;const shouldDropConsole = process.env.SHOULD_DROP_CONSOLE === &#39;true&#39;;const enableVConsole = process.env.ENABLE_VCONSOLE === &#39;true&#39;;const localIdentName = &#39;[local]-[hash:base64:5]&#39;;module.exports = &#123;  /**   * 扩展 babel 配置   */  babel: &#123;    loaderOptions: &#123;      /**       * Babel 编译时，会处理 core-js（未来可能会被修复），       * 导致 polyfill 内部代码发生了变化，产生一些微小的影响，如 Symbol 问题。       * 暂时我们手动声明略过。       * https://github.com/zloirock/core-js/issues/514       * https://github.com/rails/webpacker/pull/2031       */      exclude: [        /node_modules[\\/]core-js/,        /node_modules[\\/]react-app-polyfill/,      ],    &#125;,    presets: [      [        &#39;@babel/preset-env&#39;,        &#123;          modules: false, // 对 ES6 的模块文件不做转化，以便使用 webpack 支持的 tree shaking、sideEffects          useBuiltIns: &#39;entry&#39;, // entry ☞ 指定的 browserslist 环境，不支持的特性垫片都导入          // https://babeljs.io/docs/en/babel-preset-env#usebuiltins          // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md          corejs: &#123;            version: 3, // 使用 core-js@3            proposals: true,          &#125;,        &#125;,      ],    ],    plugins: [      /**       * AntDesign 按需加载       */      [        &#39;babel-plugin-import&#39;,        &#123;          libraryName: &#39;antd&#39;,          libraryDirectory: &#39;es&#39;,          style: true,        &#125;,        &#39;antd&#39;,      ],      [        // @babel/plugin-proposal-decorators 需要在 @babel/plugin-proposal-class-properties 之前，保证装饰器先处理        &#39;@babel/plugin-proposal-decorators&#39;,        &#123;          legacy: true, // 推荐        &#125;,      ],      [        &#39;@babel/plugin-proposal-class-properties&#39;,        &#123;          loose: true, // babel 编译时，对 class 的属性采用赋值表达式，而不是 Object.defineProperty（更简洁）        &#125;,      ],      /**       * babel-plugin-react-css-modules       *  - GitHub: https://github.com/gajus/babel-plugin-react-css-modules       *  - http://ekoneko.github.io/blog/engineering/stop-using-css-in-js/       *  - https://zhuanlan.zhihu.com/p/26878157       */      [        &#39;react-css-modules&#39;,        &#123;          exclude: &#39;node_modules&#39;,          filetypes: &#123;            &#39;.scss&#39;: &#123;              syntax: &#39;postcss-scss&#39;,            &#125;,            &#39;.less&#39;: &#123;              syntax: &#39;postcss-less&#39;,            &#125;,          &#125;,          // 必须保持和 css-modules 的 localIdentName 一致的命名          // https://github.com/gajus/babel-plugin-react-css-modules/issues/291          // generic-names 用于解决 css-loader v4 hash 的兼容          generateScopedName: genericNames(localIdentName),          webpackHotModuleReloading: true,          autoResolveMultipleImports: true,          handleMissingStyleName: &#39;warn&#39;,        &#125;,      ],      /**       * https://github.com/tleunen/babel-plugin-module-resolver       *       * 解决 babel-plugin-react-css-modules 不兼容 webpack alias 问题       *       * Support for Webpack resolve aliases       *  https://github.com/gajus/babel-plugin-react-css-modules/issues/46       */      [        &#39;module-resolver&#39;,        &#123;          alias: &#123;            &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),          &#125;,        &#125;,      ],    ],  &#125;,  style: &#123;    /**     * css modules 配置     */    modules: &#123;      // 必须保持和 babel-plugin-react-css-modules 一致的命名      localIdentName,    &#125;,  &#125;,  /**   * 扩展 webpack 相关配置   */  webpack: &#123;    /**     * 新增 webpack plugin     */    plugins: [      /**       * 模块间循环依赖检测插件       *  - https://juejin.im/post/6844904017848434702       */      ...whenDev(        () =&gt; [          new CircularDependencyPlugin(&#123;            exclude: /node_modules/,            include: /src/,            failOnError: true,            allowAsyncCycles: false,            cwd: process.cwd(),          &#125;),        ],        []      ),      /**       * 编译产物分析       *  - https://www.npmjs.com/package/webpack-bundle-analyzer       */      ...when(isBuildAnalyzer, () =&gt; [new BundleAnalyzerPlugin()], []),      /**       * vconsole-webpack-plugin       *  - 生产环境，强制不会生效       *       * 必须 entry 为数组插件才能生效，如果不是需自己改写       * https://github.com/diamont1001/vconsole-webpack-plugin/issues/44       */      ...when(        !isBuildProd,        () =&gt; [          new vConsolePlugin(&#123;            enable: !isBuildProd &amp;&amp; enableVConsole,          &#125;),        ],        []      ),    ],    /**     * 重写 webpack 任意配置     *  - configure 能够重写 webpack 相关的所有配置，但是，仍然推荐你优先阅读 craco 提供的快捷配置，把解决不了的配置放到 configure 里解决；     *  - 这里选择配置为函数，与直接定义 configure 对象方式互斥；     */    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;      /**       * 改写 entry 为数组，确保 vconsole-webpack-plugin 可以生效       * https://github.com/diamont1001/vconsole-webpack-plugin/issues/44       */      if (isProd &amp;&amp; typeof webpackConfig.entry === &#39;string&#39;) &#123;        webpackConfig.entry = [webpackConfig.entry];      &#125;      /**       * 修改 output       */      webpackConfig.output = &#123;        ...webpackConfig.output,        ...when(          isProd,          () =&gt; (&#123;            // 命名上移除 chunk 字样            chunkFilename: &#39;static/js/[name].[contenthash:8].js&#39;,          &#125;),          &#123;&#125;        ),        // 支持移除 js 文件名的 hash 值        ...when(          isProd &amp;&amp; removeFilenameHash,          () =&gt; (&#123;            filename: &#39;static/js/[name].js&#39;,            chunkFilename: &#39;static/js/[name].js&#39;,          &#125;),          &#123;&#125;        ),      &#125;;      /**       * 配合私有 source map 文件，修改 map 文件链接时，需设置为 false       * （仅编译生产代码时修改 map 文件链接）       */      webpackConfig.devtool = isBuildProd ? false : webpackConfig.devtool;      /**       * 扩展 extensions       */      webpackConfig.resolve.extensions = [        ...webpackConfig.resolve.extensions,        ...[&#39;.scss&#39;, &#39;.less&#39;],      ];      webpackConfig.resolve.plugins = [        ...webpackConfig.resolve.plugins,        ...[          /**           * 自动将 tsconfig 里的 paths 注入到 webpack alias           * （意味着你不再需要额外增加 webpack alias）           *  - https://github.com/dividab/tsconfig-paths-webpack-plugin           */          new TsconfigPathsPlugin(&#123;            extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.js&#39;, &#39;.jsx&#39;],          &#125;),        ],      ];      webpackConfig.optimization.minimizer.map(plugin =&gt; &#123;        /**         * TerserPlugin         */        if (plugin instanceof TerserPlugin) &#123;          Object.assign(plugin.options.terserOptions.compress, &#123;            drop_debugger: shouldDropDebugger, // 删除 debugger            drop_console: shouldDropConsole, // 删除 console          &#125;);        &#125;        return plugin;      &#125;);      /**       * webpack split chunks       */      webpackConfig.optimization.splitChunks = &#123;        ...webpackConfig.optimization.splitChunks,        ...&#123;          chunks: &#39;all&#39;,          name: true,        &#125;,      &#125;;      /**       * 覆盖已经内置的 webpack plugins       */      webpackConfig.plugins.map(plugin =&gt; &#123;        /**         * 支持移除 css 文件名的 hash 值         */        whenProd(() =&gt; &#123;          if (plugin instanceof MiniCssExtractPlugin) &#123;            Object.assign(              plugin.options,              &#123;                // 命名上移除 chunk 字样                chunkFilename: &#39;static/css/[name].[contenthash:8].css&#39;,              &#125;,              when(                removeFilenameHash,                () =&gt; (&#123;                  filename: &#39;static/css/[name].css&#39;,                  chunkFilename: &#39;static/css/[name].css&#39;,                &#125;),                &#123;&#125;              )            );          &#125;        &#125;);        return plugin;      &#125;);      // 返回重写后的新配置      return webpackConfig;    &#125;,  &#125;,  /**   * 新增 craco 提供的 plugin   */  plugins: [    /**     * 支持 less     *  - https://github.com/DocSpring/craco-less     *  - options 参数：https://github.com/DocSpring/craco-less#configuration     */    &#123;      plugin: CracoLessPlugin,      options: &#123;        modifyLessRule(lessRule, context) &#123;          return &#123;            ...lessRule,            ...&#123;              test: /\.less$/,              exclude: /\.module\.less$/,            &#125;,          &#125;;        &#125;,        lessLoaderOptions: &#123;          lessOptions: &#123;            // 自定义 antd 主题            modifyVars: antdTheme,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,    /**     * 支持 less module     *  - https://github.com/DocSpring/craco-less#configuration     */    &#123;      plugin: CracoLessPlugin,      options: &#123;        modifyLessRule(lessRule, context) &#123;          return &#123;            ...lessRule,            ...&#123;              test: /\.module\.less$/,              exclude: undefined,            &#125;,          &#125;;        &#125;,        cssLoaderOptions: &#123;          modules: &#123;            // 必须保持和 babel-plugin-react-css-modules 一致的命名            localIdentName,          &#125;,        &#125;,      &#125;,    &#125;,    /**     * react scoped css (only scss/css)     *  - https://github.com/gaoxiaoliangz/react-scoped-css     */    &#123;      plugin: CracoScopedCssPlugin,    &#125;,  ],&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> create-react-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1px 细线实现</title>
      <link href="/2020/08/26/css/border/"/>
      <url>/2020/08/26/css/border/</url>
      
        <content type="html"><![CDATA[<p>采用缩放方案，单条边线好处理一点；如果需要四边都有边线，会有点麻烦，使用缩放方案，虽然可行，但是在部分设备上有间隙问题，建议放弃，或者使用 svg 来做 background-image。</p><p>以下是 less/sass 的简单实现示例。</p><h3 id="LESS-上边线-1px"><a href="#LESS-上边线-1px" class="headerlink" title="LESS 上边线 1px"></a>LESS 上边线 1px</h3><pre><code class="less">.border-top(@color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    top: 0;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-top: 1px solid @color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  .border-top(#eee);&#125;</code></pre><h3 id="SASS-上下-1px-细线"><a href="#SASS-上下-1px-细线" class="headerlink" title="SASS 上下 1px 细线"></a>SASS 上下 1px 细线</h3><pre><code class="scss">/** * 1px细线 *  $position top/bottom */@mixin border-1px($position, $color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    @if $position == top &#123;      top: 0;    &#125;    @if $position == bottom &#123;      bottom: 0;    &#125;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-#&#123;$position&#125;: 1px solid $color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  // 上边线  @include border-1px(top, #e9e9e9);  // 下边线  @include border-1px(bottom, #e9e9e9);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 1px-border </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块间循环引用问题</title>
      <link href="/2020/06/11/nodejs/circular-deps/"/>
      <url>/2020/06/11/nodejs/circular-deps/</url>
      
        <content type="html"><![CDATA[<p>有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。</p><p>类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的模块……</p><p>为了更好地避免这样的问题，可以使用 <a href="https://github.com/aackerman/circular-dependency-plugin">circular-dependency-plugin</a> 插件来做循环引用的检测:</p><p>基本用法如下，复制、粘贴即可生效：</p><pre><code class="js">// webpack.config.jsconst CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)module.exports = &#123;  plugins: [    new CircularDependencyPlugin(&#123;      // exclude detection of files based on a RegExp      exclude: /node_modules/,      // include specific files based on a RegExp      include: /src/,      // add errors to webpack instead of warnings      failOnError: true,      // allow import cycles that include an asyncronous import,      // e.g. via import(/* webpackMode: &quot;weak&quot; */ &#39;./file.js&#39;)      allowAsyncCycles: false,      // set the current working directory for displaying module paths      cwd: process.cwd(),    &#125;)  ]&#125;</code></pre><p>检测到问题时，会看到如下图的编译提示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/10/16eefa622ebb1ebf?w=1060&h=230&f=png&s=51565" alt=""></p><p>如何解决循环引用的问题？将被循环引用到的模块提取放到另外的模块，打破这个循环即可！</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li><a href="https://www.imooc.com/article/260265">webpack 与循环引用</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">JavaScript 模块的循环加载</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动修改 node_moduels 源码</title>
      <link href="/2020/06/11/nodejs/patch-package/"/>
      <url>/2020/06/11/nodejs/patch-package/</url>
      
        <content type="html"><![CDATA[<p>有时候 node_modules 中的第三方包有问题或需要修改几行源码，我们可以怎么办？</p><ol><li><p>去给作者提 issues？可能得不到回复。</p></li><li><p>自己在 node_modules 里直接修改源码？下一次重新安装包，或者其他同事 install 的时候，被修改过的源码又恢复如初了。</p></li><li><p>不用他的包，自己写一个？……</p></li></ol><p>社区提供了一个工具：<a href="https://github.com/ds300/patch-package">patch-package</a>，专门用来处理修改 node_modules 包源码的问题。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用方法如下，注意 yarn、npm 使用时的差异，推荐使用 yarn。</p><ol><li><p>安装 patch-package</p><pre><code class="sh"># yarn 需要多安装一个包 postinstall-postinstall，https://github.com/ds300/patch-package#why-use-postinstall-postinstall-with-yarnyarn add patch-package postinstall-postinstall -D# or# npmnpm i patch-package -D</code></pre></li><li><p>在 package.json 的 scripts 中增加如下命令：</p><pre><code class="json">&quot;scripts&quot;: &#123;+  &quot;postinstall&quot;: &quot;patch-package&quot;&#125;</code></pre><p><code>postinstall</code> 是 npm 的钩子，会在依赖包被 <code>install</code> 之后被执行。</p></li><li><p>上面两步都做了，就可以去修改 node_modules 里任意第三方包的源码了。</p></li><li><p>修改了源码，随后需要执行以下命令：</p><pre><code class="sh"># [package-name] 是包名，不需要写路径。yarn patch-package [package-name]# ornpx patch-package [package-name]</code></pre><p>命令执行成功后，会发现项目根目录下多了一个文件夹 <code>patches</code>，该目录下多了文件，即为记录源码修改的文件。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bce8d8e01745?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>将 <code>patches</code> 目录及文件，通过 git 提交到代码仓库。</p></li><li><p>Over，后续其他同学不需要做额外操作，直接安装即可，node_modules 下的源码修改会自动更新。</p><p>之前已经安装过该第三方包的同学，需要卸载，重新安装一次。</p></li><li><p>如果后续还有其它包也需要修改源码，修改过后，再执行一次命令：</p><pre><code class="sh">yarn patch-package [package-name]# ornpx patch-package [package-name]</code></pre></li></ol><h2 id="直接提交-issues"><a href="#直接提交-issues" class="headerlink" title="直接提交 issues"></a>直接提交 issues</h2><p>完成上述步骤后，你甚至可以通过一行命令向第三方包提交 issues。</p><p>示例截图：</p><p><img src="/imgs/patch_pkg_create_issues.png" alt=""></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li><p>过程中遇到一个错误，记录一下，其他人不一定会遇到。</p><p>macos 在终端报如下错误:</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bcf316c96916?w=2240&h=288&f=png&s=90956" alt=""></p><p>可以参照这个文档解决：<a href="https://www.cnblogs.com/start-fxw/p/10192226.html">https://www.cnblogs.com/start-fxw/p/10192226.html</a></p><p>终端运行如下命令：</p><pre><code class="bash">xcode-select --install</code></pre><p>更新一下 xcode 即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM 包发布指南</title>
      <link href="/2020/05/10/npm/publish/"/>
      <url>/2020/05/10/npm/publish/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在 NPM 官网注册账号，<a href="https://www.npmjs.com">https://www.npmjs.com</a></p><p>邮件验证的时候可能需要翻墙访问。</p></li><li><p>本机安装 nodejs</p></li><li><p>推荐也安装一下 nrm，方便随时切换 npm 源</p><pre><code class="sh">sudo npm i nrm -g</code></pre><p>nrm 常用命令</p><pre><code class="sh">nrm ls                  # 查看所有nrm use [目标源]         # 切换至目标源</code></pre></li></ol><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>包的<strong>根目录</strong>需要有一个 package.json 文件，可以通过 <code>npm init</code> 命令去创建，示例如下：</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;@eleven.fe/reset.css&quot;,  &quot;version&quot;: &quot;1.0.6&quot;,  &quot;description&quot;: &quot;H5 网页 reset 方案，PC&amp;mobile&quot;,  &quot;main&quot;: &quot;lib/reset.css&quot;,  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;npm publish . --access=public&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/eleven-net-cn/reset.css.git&quot;  &#125;,  &quot;keywords&quot;: [&quot;reset.css&quot;],  &quot;author&quot;: &quot;Eleven&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/eleven-net-cn/reset.css/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/eleven-net-cn/reset.css#readme&quot;,  &quot;files&quot;: [&quot;lib&quot;, &quot;ReadMe.md&quot;]&#125;</code></pre><p><strong>重点注意以下几项：</strong></p><ol><li><p>main：指定包的入口文件</p></li><li><p>name：指定包名</p><ul><li>发布之前都要去<a href="https://www.npmjs.com">NPM 官网</a>上搜索一遍，确认想要使用的包名，是否已经被占用。</li><li>包名支持 [@scope]/[package name] 的形式，[@scope] 类似于命名空间的作用，NPM 默认允许你使用自己注册的用户名，或者在自己的账户下申请的 organizations。<br>典型的例子，如 Babel，插件原先使用的是 babel-plugin-xxx 的格式命名，后来因为许多个人发布的包和官方的包命名格式一样，导致难以区分，现在 babel 官方所有的包都更换成了 @babel/xxx 的格式。</li></ul></li><li><p>version：包的版本</p><ul><li>格式 <code>数字.数字.数字</code>，每一次发布，版本都必须要更新，只能往上增加。</li></ul></li><li><p>keywords：关键词</p><ul><li>希望别人通过哪些关键词搜索到你的包，可以在这里添加。</li></ul></li><li><p>files：指定哪些文件夹、文件将被发布</p><ul><li><p>如果你的项目目录下包含了一些隐私文件，不希望被发布出去，一定要注意配置此项，仅包含可以被发布的文件夹、文件。</p></li><li><p>可以在包的根目录下新建文件 <code>.npmignore</code>，指定哪些文件不被发布，书写格式与 <code>.gitignore</code> 文件一致。</p></li></ul></li><li><p>license：协议，推荐阅读了解几种开源的协议：</p><ul><li><p><a href="https://www.jianshu.com/p/86251523e898">七种开源许可证</a></p></li><li><p><a href="https://spdx.org/licenses/">SPDX License List</a></p></li></ul></li><li><p>description、repository、author、bugs、homepage 等项，通常也推荐填写完整，详细的 package.json 每一项的含义，推荐阅读这一篇：<a href="https://blog.csdn.net/zhengxiuchen86/article/details/81285030">npm package.json 属性详解</a> 。</p></li></ol><h2 id="待发布的包结构"><a href="#待发布的包结构" class="headerlink" title="待发布的包结构"></a>待发布的包结构</h2><ol><li><p>移除不必要的代码</p><p>发布出去的包，一般只需要包含用户使用时必须要 <code>install</code> 下载的文件即可，例如一些构建脚本等无关的代码文件，不必发布出去。</p><p>例如：你有一个开源项目，同时，该项目也提供了包供开发者使用，最佳方式应该是将该项目源码推送到 GitHub 上开源，而发布到 NPM 仓库的包，尽量不要把项目源码目录、构建脚本等非必要的文件发布到 NPM 仓库，会增大包的体积，导致安装时间变长。</p></li><li><p>发布的包尽量要做好语法转译，否则要在文档中说明，提醒使用者自己完成。</p></li><li><p>保护隐私</p><p>如果待发布的包，并非开源项目，而仅仅是为了提供开发者 NPM 安装、使用，一定要做好隐私保护工作，防止源码、隐私的文档等隐秘信息被发布到 NPM 仓库。</p><p>可以选用的方法如下：</p><ol><li><p><code>.gitignore</code> 设置忽略哪些文件</p><p>.gitignore 设置的忽略文件，在 git 代码管理和 npm publish 都会被忽略。</p></li><li><p>.npmignore 设置忽略哪些文件</p><p>.npmignore 优先级更高，如果同时使用了 .npmignore 和 .gitignore，只有 .npmignore 会生效。</p></li><li><p>package.json 文件的 files 字段</p><p>直接在 package.json 文件中配置 <code>files</code>，指定发布哪些文件、目录，优先级高于 .npmignore 和 .gitignore。</p></li></ol></li><li><p>以下文件、目录在发布时，默认会被忽略</p><pre><code class="txt">.*.swp._*.DS_Store.git.hg.npmrc.lock-wscript.svn.wafpickle-*config.gypiCVSnpm-debug.lognode_modules/</code></pre></li><li><p>以下文件、目录在发布时，默认会被包含，无法忽略掉</p><pre><code class="txt">package.jsonREADME (and its variants)CHANGELOG (and its variants)LICENSE / LICENCE</code></pre></li></ol><h2 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h2><ol><li><p>登录 NPM 账号</p><ol><li><p>在终端运行命令，填写账号、密码及邮箱。</p><pre><code class="sh">npm adduser / npm login</code></pre></li><li><p>查看是否登录上了？</p><pre><code class="sh">npm who am i</code></pre></li><li><p>通常只有一个人可以发布，也可以添加多人，相关命令如下：</p><pre><code class="sh">npm owner ls &lt;package name&gt;             # 查看npm owner add &lt;user&gt; &lt;package name&gt;     # 添加npm owner rm &lt;user&gt; &lt;package name&gt;      # 删除</code></pre></li></ol></li><li><p>发布</p><pre><code class="sh">npm publish . --access=public</code></pre><ol><li><p>这里注意一下发布命令中的点 <code>.</code> ，如果不带 <code>.</code> ，偶尔碰到发布会出错。</p></li><li><p>包名重复（或者说已被占用）、未登录，都会导致发布失败，注意看提示信息。</p></li><li><p>注意版本号必须要递增，相同的版本号或版本号递减会发布失败。</p></li></ol></li></ol><h2 id="撤回已发布的版本"><a href="#撤回已发布的版本" class="headerlink" title="撤回已发布的版本"></a>撤回已发布的版本</h2><pre><code class="sh">npm unpublish -f &lt;package name&gt;@&lt;package version&gt;</code></pre><ol><li><p>包发布后的 72 小时内，可以撤回。</p></li><li><p>已撤回的版本，该版本号就不能再重新发布了，因为在 NPM 的仓库中已经有了记录。</p></li></ol><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><ol><li><p>偶尔可能会看到如下错误:</p><pre><code class="sh">no_perms Private mode enable, only admin can publish this module</code></pre><p>解决办法：</p><pre><code class="sh">npm config set registry http://registry.npmjs.org</code></pre></li><li><p>NPM 官方提供了发布的指导：<a href="https://docs.npmjs.com/misc/developers">https://docs.npmjs.com/misc/developers</a> ，如果遇到一些奇怪的问题，建议前往阅读。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规范 git commit</title>
      <link href="/2020/03/25/git/commit/"/>
      <url>/2020/03/25/git/commit/</url>
      
        <content type="html"><![CDATA[<p>如何让 <code>git commit</code> 提交时更加规范？例如：vue、angular，如下图。规范化地提交记录，会让将来的回溯查找更容易，也让其他人阅读起来更加简便。</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172081ff77566188?w=996&h=1021&f=png&s=251160" alt=""></p><p>最近读到一篇不错的文章（<a href="https://juejin.im/post/5e0c82a15188253a907111dc">你可能已经忽略的 git commit 规范</a>），吸取下养分，顺便做个记录。文章介绍得很清楚，建议阅读原文，不做额外赘述，以下为集成到项目的快速指南。</p><h2 id="快速指南"><a href="#快速指南" class="headerlink" title="快速指南"></a>快速指南</h2><p>使用到的工具 <a href="https://github.com/commitizen/cz-cli">commitizen</a>、<a href="https://github.com/typicode/husky">husky</a>、<a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a>，cz-conventional-changelog 是 angular 的 commit message 格式。</p><p>所有包不推荐 global 安装，而仅项目本地安装，方便多人开发时，减少其他人的额外操作。</p><ol><li><p>安装工具</p><pre><code class="bash"> yarn add commitizen cz-conventional-changelog -D</code></pre></li><li><p>在项目根目录的 package.json 中添加配置</p><pre><code class="json"> &#123;   &quot;scripts&quot;: &#123;     &quot;commit&quot;: &quot;git-cz&quot;   &#125;,   &quot;config&quot;: &#123;     &quot;commitizen&quot;: &#123;       &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;     &#125;   &#125; &#125;</code></pre><p> 官方推荐的是 global 安装 commitizen，然后执行 <code>commitizen init cz-conventional-changelog --yarn --dev --exact</code> 去自动添加 cz-conventional-changelog，自动在 package.json 中添加 config 配置，不太推荐这种方式。</p></li><li><p>使用</p><ul><li><p><code>git commit</code> 仍然是普通的 git 提交模式</p></li><li><p><code>yarn commit</code> 会执行交互式 commit 提交，在终端跟着提示一步步输入即可。</p></li></ul></li><li><p>限制每一次 <code>git commit</code> 都执行交互式提交</p><p> 如果想要更暴力一点，限制每一次 <code>git commit</code> 都自动执行规范化地提交，可以配置 git 提交的钩子，借助 husky 更方便一点（不用 husky 当然也可以）。</p><p> 先将 scripts 中配置的 commit 命令删除，不再需要了。</p><p> 安装 husky</p><pre><code class="bash"> yarn add husky -D</code></pre><p> 在 package.json 中增加配置</p><pre><code class="json"> &#123;   &quot;husky&quot;: &#123;     &quot;hooks&quot;: &#123;       &quot;prepare-commit-msg&quot;: &quot;exec &lt; /dev/tty &amp;&amp; git cz --hook || true&quot;     &#125;   &#125;, &#125;</code></pre><p> 有些时候可能不太需要所有的 commit 都执行规范化的提交流程，因此，推荐不要这么暴力限制，而是仅在关键性的提交步骤才执行。</p></li></ol><h2 id="在提交中支持表情符号"><a href="#在提交中支持表情符号" class="headerlink" title="在提交中支持表情符号"></a>在提交中支持表情符号</h2><p>如果想要在提交中使用一些表情符号，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172086dbf52c646f?w=2016&h=1570&f=png&s=405106" alt=""></p><p>可以借助 <a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a></p><p>安装</p><pre><code class="bash">yarn add gitmoji-cli -D</code></pre><p>使用方法：在提交时按照约定格式输入表情字符即可（左右两边英文冒号夹着字符，例如bug ☞ <code>:bug:</code>），提交后会自动被显示，示例：</p><pre><code class="bash">git commit -m &quot;fix(src): :bug: 修复列表显示问题&quot;</code></pre><p>如果想要查看所有的表情符号及介绍，可以<a href="https://gitmoji.carloscuesta.me/">去官方文档查阅</a>。</p><p>或者，<code>npx gitmoji-cli -l</code> 查看。</p><p>如果全局安装 <code>npm i -g gitmoji-cli</code>，则执行 <code>gitmoji -l</code> 命令查看。</p><h2 id="常见的-commit-类型"><a href="#常见的-commit-类型" class="headerlink" title="常见的 commit 类型"></a>常见的 commit 类型</h2><ul><li>feat: 新增feature</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档，如readme.md</li><li>style: 仅仅是对格式进行修改，如逗号、缩进、空格等。不改变代码逻辑。</li><li>refactor: 代码重构，没有新增功能或修复bug</li><li>perf: 优化相关，如提升性能、用户体验等。</li><li>test: 测试用例，包括单元测试、集成测试。</li><li>chore: 改变构建流程、或者增加依赖库、工具等。</li><li>revert: 版本回滚</li></ul><h2 id="手写-commit-的推荐写法"><a href="#手写-commit-的推荐写法" class="headerlink" title="手写 commit 的推荐写法"></a>手写 commit 的推荐写法</h2><p>如果通过简单的 git commit -m “” 提交，你大概可以这样写：</p><pre><code class="bash">git commit -m &quot;feat(player): 播放功能开发完成&quot;</code></pre><p>引号内即 commit 的 message:</p><ul><li>feat 表明本次提交的类型</li><li>括号内容是本次代码的影响目录/文件</li><li>冒号后面是本次提交的简短描述（冒号后面推荐来个空格）  </li></ul><p>加点表情符号（当然，你要先安装 gitmoji-cli）：</p><pre><code class="bash">git commit -m &quot;feat(player): :rocket: 播放功能开发完成&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Hook 提交时修改版本号</title>
      <link href="/2020/03/12/nodejs/check-version/"/>
      <url>/2020/03/12/nodejs/check-version/</url>
      
        <content type="html"><![CDATA[<p>前端项目在 Git 提交时，往往会遗忘更新项目根目录的 package.json 文件的 version，通常不修改也不会有啥问题，但对于强迫症来说，不能忍！咱要改掉它……</p><h4 id="编写一个简单的-node-脚本-check-version-js"><a href="#编写一个简单的-node-脚本-check-version-js" class="headerlink" title="编写一个简单的 node 脚本 check-version.js"></a>编写一个简单的 node 脚本 <code>check-version.js</code></h4><p>先安装几个依赖包 <code>yarn add inquirer chalk child_process -D</code></p><pre><code class="js">// /scripts/check-version.jsconst inquirer = require(&#39;inquirer&#39;);const chalk = require(&#39;chalk&#39;);const &#123; exec &#125; = require(&#39;child_process&#39;);const &#123; name: projectName, version: versionCurrent &#125; = require(&#39;../package&#39;);const regVersion = /^[1-9]&#123;1&#125;\d*\.\d+\.\d+$/; // 示例: 1.0.0// const regVersion = /^\d+\.\d+\.\d+$/ // 示例: 0.0.1 / 1.0.1// const regVersion = /^\d+\.\d+\.\d+(-beta.?\d*)?$/ // 示例: 1.0.3 / 0.0.1-beta / 1.0.0-beta.3console.log(&#39;\n&#39;);// 确认 package.json 版本号inquirer  .prompt([    &#123;      type: &#39;input&#39;,      name: &#39;version&#39;,      message: `请确认 $&#123;projectName&#125;/package.json/version 版本号（当前：$&#123;versionCurrent&#125;）：\n`,      default: versionCurrent,      validate(version) &#123;        // 校验版本号的格式        if (!regVersion.test(version)) &#123;          console.log(chalk.yellow(&#39;输入的版本号无效，请检查格式（示例：1.0.0、2.3.2）&#39;));          return false;        &#125;        return true;      &#125;,    &#125;,  ])  .then((&#123; version: versionNew &#125;) =&gt; &#123;    if (versionNew !== versionCurrent) &#123;      // 更新 package.json version，更新时不自动生成 tag      command(`npm --no-git-tag-version version $&#123;versionNew&#125;`, &#123;&#125;, (error, stdout, stderr) =&gt; &#123;        if (!error) &#123;          console.log(            chalk.green(              `\n$&#123;projectName&#125; 版本号（项目根目录下的 package.json/version）更新成功，version: $&#123;versionNew&#125; ！`,            ),          );          command(            `git add package.json &amp;&amp; git commit -m &#39;ci(package.json): 更新项目版本号为：$&#123;versionNew&#125;&#39;`,          );          console.log(`\n`);          process.exit(0);        &#125; else &#123;          console.log(chalk.yellow(`\n更新版本号（$&#123;versionNew&#125;）失败了~\n`));          process.exit(1);        &#125;      &#125;);    &#125; else &#123;      console.log(chalk.green(`\n本次版本号未做修改，version: $&#123;versionNew&#125; ！\n`));    &#125;  &#125;);function command(cmd, options, callback) &#123;  console.log(&#39;\n&#39;);  console.log(chalk.cyan(cmd.toString()));  return exec(cmd, &#123; ...options &#125;, callback);&#125;</code></pre><h4 id="配置-Git-钩子"><a href="#配置-Git-钩子" class="headerlink" title="配置 Git 钩子"></a>配置 Git 钩子</h4><ol><li><p>先安装 <code>yorkie</code>，用于管理 git 钩子，当然，使用原生的也可以。</p><pre><code class="bash">yarn add yorkie -D</code></pre></li><li><p>在项目的 package.json 文件中增加以下配置：</p><pre><code class="json">&quot;gitHooks&quot;: &#123;  &quot;post-commit&quot;: &quot;exec &lt; /dev/tty &amp;&amp; node scripts/check-version.js&quot;&#125;,</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>完成以上配置后，后续在执行 git commit 提交代码时，会自动在终端弹出交互，提示修改 package.json 文件的 version，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729d6b37f7e5254?w=1326&h=348&f=png&s=55796" alt=""></p><p>如果不需要修改直接敲击 Enter 跳过，需要则输入新的版本号，会自动执行命令修改 package.json 文件的 version，并自动提交刚刚的修改，接下来 <code>git push</code> 推送代码即可。</p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> NPM </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令清单</title>
      <link href="/2020/03/02/git/command/"/>
      <url>/2020/03/02/git/command/</url>
      
        <content type="html"><![CDATA[<p>Git 常用命令做一波整理，方便随时查阅。</p><blockquote><p>主要内容出自阮一峰大佬的科普文章：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a> 。</p></blockquote><p>几个专用名词的译名如下：</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code class="zsh"># 在当前目录新建一个 Git 代码库$ git init# 新建一个目录，将其初始化为 Git 代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git 的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code class="zsh"># 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息(设置本机的用户名,邮箱)$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;# 查看用户信息$ git config user.name -g$ git config user.email -g# 查看公开密钥$ cat ~/.ssh/id_rsa.pub# 验证密钥是否已连接成功(以 github 为例)$ ssh -T git@github.com# 创建 SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example&quot;# 解决每次要求输入用户名/密码的问题$ git config --global credential.helper store# 设置 http 代理$ git config --global http.proxy 10.100.10.100:3128# 设置 Git 对文件/文件夹大小写敏感$ git config core.ignorecase false# gitlab ip 变化后$ rm -rf ~/.ssh/known_hosts 删除后重新操作即可</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code class="zsh"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .$ git add -A 添加所有文件# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code class="zsh"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做上一次 commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code class="zsh"># 有时候看不到远程的分支,那么更新下远程库的索引$ git fetch# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 拉取一个本地不存在的新分支,并切换到该分支$ git checkout -b [branch-name] [origin/branch-name]# 新建一个分支，指向指定 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除分支(如果要删除的分支,本地仓库有代码没有 push 到远程仓库,-d 是删不掉的,需要用-D; 切回去先 push 再删也行.)$ git branch -D [branch-name]# 批量删除本地分支（排除 master/develop/test 分支）$ git branch -a | grep -v -E &#39;master|develop|test&#39; | xargs git branch -D# 批量删除本地分支（仅包含 releases）$ git branch -a | grep &#39;releases&#39; | xargs git branch -D# 批量删除远程分支（排除 master/develop/test 分支）$ git branch -r| grep -v -E &#39;master|develop|test&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;# 批量删除远程分支（仅包含 releases）$ git branch -r| grep &#39;releases&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;# 重命名分支(不会覆盖已存在的同名分支)$ git branch -m [branch-name] [new-name]# 重命名分支(会覆盖已存在的同名分支)$ git branch -M [branch-name] [new-name]# 删除远程分支$ git push origin -d [branch-name] （将服务器上的“远程分支”删除，删除远程分支常用这个。）$ git branch -dr [remote/branch] （仅将本地的“远程分支”删除）# 处理已经不存在的分支（有时不存在了，但仍然显示）$ git remote show origin 查看远程库和分支的情况$ git remote prune origin 可以移除一些已经不存在的分支# 比较两个分支不同$ git diff [分支 A] [分支 B] &gt;&gt; xx.txt （比较两个分支不同，输出到某文本）</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code class="zsh"># 列出所有 tag$ git tag# 新建一个 tag 在当前 commit$ git tag [tag]# 新建一个 tag，并加上注释说明$ git tag -a [tag-name] -m &quot;some words&quot;# 新建一个 tag 在指定 commit$ git tag [tag] [commit]# 删除本地 tag$ git tag -d [tag]# 删除远程 tag$ git push origin -d [tagName]$ git push origin :refs/tags/[tagName]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]# 重命名 tag (新建 tag 指向原来的 tag =&gt; 再删除旧的 tag =&gt; 并删除远程旧 tag)$ git tag [new-tag-name] [old-tag-name]$ git tag -d [old-tag-name]$ git push [remote] -d [old-tag-name]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code class="zsh"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat# 查看分支合并图$ git log --graph# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次 diff$ git log -p [file]# 显示过去 5 次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个 commit 的差异$ git diff --cached [file]# 显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code class="zsh"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库(本地仓库与远程仓库建立连接)，并命名(别名)$ git remote add [shortname] [url]# 删除一个远程仓库$ git remote rm [shortname]# 远程仓库更名后,修改连接地址$ git remote set-url [shortname] [new-url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 推送分支到远程仓库(第一次需要-u,建立关系)$ git push -u [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --forcegit push [remote] -f# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p>checkout，没有 add 到暂存区的，撤回到版本库的状态; 已 add 到暂存区未 commit，其后的修改，撤回到暂存区状态。</p><pre><code class="zsh"># 恢复暂存区的指定文件到工作区 (回退某文件到工作区)$ git checkout [file]# 恢复某个 commit 的指定文件到暂存区和工作区 (回退到未 commit 状态)$ git checkout [commit] [file]# 例如: git checkout 36393f5fc07e54f6704d23d4d92bf0b3773e523c xxx/main/src/util/eg.js# 恢复暂存区的所有文件到工作区 (回退所有文件到工作区)$ git checkout .</code></pre><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>checkout 是撤销修改，reset 是在版本间穿梭。</p><pre><code class="zsh"># 重置指定文件到指定版本$ git reset [版本号] [文件路径(从顶层一路相对下来)]# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区$ git reset HEAD# 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit] =&gt; 回退到某个版本$ git reset --hard HEAD~1 =&gt; 回退到上一个版本# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支# 适用场景： 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。$ git revert [commit]</code></pre><p>Reset 和 Revert 的对比：<a href="https://blog.csdn.net/yxlshk/article/details/79944535">https://blog.csdn.net/yxlshk/article/details/79944535</a></p><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p>stash 可用于临时解决 bug 时，将眼前的工作隐藏；随后切换到解决 bug 的分支，完成 bug，提交，合并；<br>回到原先工作的分支，查看隐藏，恢复；over!</p><pre><code class="zsh"># 暂时将未提交的变化移除(隐藏工作现场)$ git stash# 将移除的移入(恢复工作现场),同时之前 stash 的内容也即删除了(不想删除,请用 apply 命令)$ git stash pop# 查看所有隐藏的工作现场$ git stash list# 恢复 XX,同时把 stash 内容删除$ git stash pop XX# 恢复 xx 但 stash 内容不删除$ git stash apply XX# 删除 XX$ git stash drop XX</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code class="zsh"># 生成一个可供发布的压缩包$ git archive# 停止追踪某文件,并保留在本地$ git rm --cached XXXX# 停止追踪某文件,并删除本地文件$ git rm --f XXXX</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
